# Copyright 2011,2012 James McCauley
#
# This file is part of POX.
#
# POX is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# POX is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with POX.  If not, see <http://www.gnu.org/licenses/>.

# This file was originally based on pyopenflow.py from NOX, which was
# autogenerated from openflow.h via a program by KK Yap.  It has been
# substantially altered since then.

from __future__ import print_function

import struct
import operator
import collections
from itertools import chain, repeat
import sys
from pox.lib.packet.packet_base import packet_base
from pox.lib.packet.ethernet import ethernet
from pox.lib.packet.vlan import vlan
from pox.lib.packet.ipv4 import ipv4
from pox.lib.packet.udp import udp
from pox.lib.packet.tcp import tcp
from pox.lib.packet.icmp import icmp
from pox.lib.packet.arp import arp

from pox.lib.addresses import *
from pox.lib.util import assert_type
from pox.lib.util import initHelper
from pox.lib.util import hexdump
from xml import _MINIMUM_XMLPLUS_VERSION
from sre_parse import isdigit



EMPTY_ETH = EthAddr(None)

# ----------------------------------------------------------------------
# XID Management
# ----------------------------------------------------------------------

MAX_XID = 0x7fFFffFF



def XIDGenerator (start = 0, stop = MAX_XID):
  i = start
  while True:
    yield i
    i += 1
    if i > stop:
      i = start

def xid_generator (start = 0, stop = MAX_XID):
  return XIDGenerator(start, stop).next

def user_xid_generator ():
  return xid_generator(0x80000000, 0xffFFffFF)

generate_xid = xid_generator()

# ----------------------------------------------------------------------


# ----------------------------------------------------------------------
# Packing / Unpacking
# ----------------------------------------------------------------------

_PAD = b'\x00'
_PAD2 = _PAD*2
_PAD3 = _PAD*3
_PAD4 = _PAD*4
_PAD6 = _PAD*6

class UnderrunError (RuntimeError):
  """
  Raised when one tries to unpack more data than is available
  """
  pass

def _read (data, offset, length):
  if (len(data)-offset) < length:
    raise UnderrunError("wanted %s bytes but only have %s"
                        % (length, len(data)-offset))
  return (offset+length, data[offset:offset+length])

def _unpack (fmt, data, offset):
  size = struct.calcsize(fmt)
  if (len(data)-offset) < size: raise UnderrunError()
  return (offset+size, struct.unpack_from(fmt, data, offset))

def _skip (data, offset, num):
  offset += num
  if offset > len(data): raise UnderrunError()
  return offset

def _unpad (data, offset, num):
  (offset, o) = _read(data, offset, num)
  assert len(o.replace("\x00", "")) == 0
  return offset

def _readzs (data, offset, length):
  (offset, d) = _read(data, offset, length)
  d = d.split("\x00", 1)
  #if len(d[1].replace("\x00", "")) > 0:
  #  raise RuntimeError("Non-zero string padding")
  assert True if (len(d) == 1) else (len(d[1].replace("\x00", "")) == 0)
  return (offset, d[0])

def _readether (data, offset):
  (offset, d) = _read(data, offset, 6)
  return (offset, EthAddr(d))

def _readip (data, offset, networkOrder = True):
  (offset, d) = _read(data, offset, 4)
  return (offset, IPAddr(d, networkOrder = networkOrder))

# ----------------------------------------------------------------------


def _format_body (body, prefix):
  if hasattr(body, 'show'):
    #TODO: Check this (spacing may well be wrong)
    return body.show(prefix + '  ')
  else:
    return prefix + hexdump(body).replace("\n", "\n" + prefix)

TABLE_ALL = 0xff
TABLE_EMERGENCY = 0xfe


class _ofp_meta (type):
  """
  Metaclass for ofp messages/structures

  This takes care of making len() work as desired.
  """
  def __len__ (cls):
    try:
      return cls.__len__()
    except:
      return cls._MIN_LENGTH


class ofp_base (object):
  """
  Base class for OpenFlow messages/structures

  You should implement a __len__ method.  If your length is fixed, it
  should be a static method.  If your length is not fixed, you should
  implement a __len__ instance method and set a class level _MIN_LENGTH
  attribute to your minimum length.
  """
  __metaclass__ = _ofp_meta

  def _assert (self):
    r = self._validate()
    if r is not None:
      raise RuntimeError(r)
      return False # Never reached
    return True

  def _validate (self):
    return None

  def __ne__ (self, other):
    return not self.__eq__(other)

  @classmethod
  def unpack_new (cls, raw, offset=0):
    """
    Unpacks wire format into the appropriate message object.

    Returns newoffset,object
    """
    o = cls()
    r,length = o.unpack(raw, offset)
    assert (r-offset) == length, o
    return (r, o)


# ----------------------------------------------------------------------
# Class decorators
# ----------------------------------------------------------------------

_message_type_to_class = {}
_message_class_to_types = {} # Do we need this?
#_message_type_to_name = {}
#_message_name_to_type = {}
ofp_type_rev_map = {}
ofp_type_map = {}

def openflow_message (ofp_type, type_val, reply_to=None,
    request_for=None, switch=False, controller=False):
  #TODO: Reply stuff, switch/controller stuff

  #_message_name_to_type[ofp_type] = type_val
  #_message_type_to_name[type_val] = ofp_type
  ofp_type_rev_map[ofp_type] = type_val
  ofp_type_map[type_val] = ofp_type
  def f (c):
    c.header_type = type_val
    c._from_switch = switch
    c._from_controller = controller
    _message_type_to_class[type_val] = c
    _message_class_to_types.setdefault(c, set()).add(type_val)
    return c
  return f

def openflow_sc_message (*args, **kw):
  return openflow_message(switch=True, controller=True, *args, **kw)

def openflow_c_message (*args, **kw):
  return openflow_message(controller=True, *args, **kw)

def openflow_s_message (*args, **kw):
  return openflow_message(switch=True, *args, **kw)

_queue_prop_type_to_class = {}
_queue_prop_class_to_types = {} # Do we need this?
ofp_queue_prop_type_rev_map = {}
ofp_queue_prop_type_map = {}

def openflow_queue_prop (queue_prop_type, type_val):
  ofp_queue_prop_type_rev_map[queue_prop_type] = type_val
  ofp_queue_prop_type_map[type_val] = queue_prop_type
  def f (c):
    c.property = type_val
    _queue_prop_type_to_class[type_val] = c
    _queue_prop_class_to_types.setdefault(c, set()).add(type_val)
    return c
  return f

_action_type_to_class = {}
_action_class_to_types = {} # Do we need this?
ofp_action_type_rev_map = {}
ofp_action_type_map = {}

def openflow_action (action_type, type_val):
  ofp_action_type_rev_map[action_type] = type_val
  ofp_action_type_map[type_val] = action_type
  def f (c):
    #c.type = type_val
    c.ofActionType = type_val
    _action_type_to_class[type_val] = c
    _action_class_to_types.setdefault(c, set()).add(type_val)
    return c
  return f

_instruction_type_to_class = {}   #add by milktank
_instruction_class_to_types = {}  #add by milktank, Do we need this?
ofp_instruction_type_rev_map = {} #add to adapt pof by milktank    
ofp_instruction_type_map = {}     #add to adapt pof  by milktank

def openflow_instruction (instruction_type, type_val):   #add by milktank
  """
  @author: milktank
  @todo:  add  class decorators for instruction class
  @edit_time: 2014-10-21 14:16:27
  @version: 1.0
  """
  ofp_instruction_type_rev_map[instruction_type] = type_val
  ofp_instruction_type_map[type_val] = instruction_type
  def f (c):
    c.ofinstructionType = type_val
    _instruction_type_to_class[type_val] = c
    _instruction_class_to_types.setdefault(c, set()).add(type_val)
    return c
  return f


class _StatsClassInfo (object):
  __slots__ = 'request reply reply_is_list'.split()

  def __init__ (self, **kw):
    self.request = None
    self.reply = None
    self.reply_is_list = False
    initHelper(self, kw)

  def __str__ (self):
    r = str(self.reply)
    if self.reply_is_list: r = "[%s]" % (r,)
    return "request:%s reply:%s" % (self.request, r)

_stats_type_to_class_info = {}
_stats_class_to_type = {}
ofp_stats_type_rev_map = {}
ofp_stats_type_map = {}

def openflow_stats_request  (stats_type, type_val=None, is_list=None,
    is_reply = False):
  if type_val is not None:
    ofp_stats_type_rev_map[stats_type] = type_val
    ofp_stats_type_map[type_val] = stats_type
  else:
    type_val = ofp_stats_type_rev_map.get(stats_type)

  def f (c):
    if type_val is not None:
      ti = _stats_type_to_class_info.get(stats_type)
      if ti is not None:
        _stats_type_to_class_info[type_val] = ti
        del _stats_type_to_class_info[stats_type]
      else:
        ti = _stats_type_to_class_info.setdefault(type_val,
            _StatsClassInfo())
      _stats_class_to_type[c] = type_val
    else:
      ti = _stats_type_to_class_info.setdefault(stats_type,
          _StatsClassInfo())

    if is_list is not None:
      ti.reply_is_list = is_list
    if is_reply:
      ti.reply = c
    else:
      ti.request = c

    if type_val is not None:
      if ti.reply and issubclass(ti.reply, ofp_stats_body_base):
        ti.reply._type = type_val
      if ti.request and issubclass(ti.request, ofp_stats_body_base):
        ti.request._type = type_val

    return c
  return f

def openflow_stats_reply (stats_type, type_val=None, is_list=None,
    is_reply = True):
  return openflow_stats_request(stats_type, type_val, is_list, is_reply)

# ----------------------------------------------------------------------


# ----------------------------------------------------------------------
# Constants, etc.
# ----------------------------------------------------------------------
"""
ofp_error_type_rev_map = {
  'OFPET_HELLO_FAILED'    : 0,
  'OFPET_BAD_REQUEST'     : 1,
  'OFPET_BAD_ACTION'      : 2,
  'OFPET_FLOW_MOD_FAILED' : 3,
  'OFPET_PORT_MOD_FAILED' : 4,
  'OFPET_QUEUE_OP_FAILED' : 5,
}
"""


ofp_error_type_rev_map = {   #modify by Tan
  'OFPET_HELLO_FAILED'    : 0,
  'OFPET_BAD_REQUEST'     : 1,
  'OFPET_BAD_ACTION'      : 2,
  'OFPET_BAD_INSTRUCTION': 3,
  'OFPET_BAD_MATCH': 4,
  'OFPET_FLOW_MOD_FAILED' : 5,
  'OFPET_GROUP_MOD_FAILED': 6,
  'OFPET_PORT_MOD_FAILED' : 7,
  'OFPET_TABLE_MOD_FAILED': 8,
  'OFPET_QUEUE_OP_FAILED' : 9,
  'OFPET_SWITCH_CONFIG_FAILED': 10,
  'OFPET_ROLE_REQUEST_FAILED': 11,
  'OFPET_METER_MOD_FAILED': 12,
  'OFPET_TABLE_FEATURES_FAILED': 13,
  'OFPET_SOFTWARE_FAILED': 14,
  'OFPET_EXPERIMENTER_ERROR': 0xFFFF
}

ofp_hello_failed_code_rev_map = {
  'OFPHFC_INCOMPATIBLE' : 0,
  'OFPHFC_EPERM'        : 1,
}

"""
ofp_bad_request_code_rev_map = {
  'OFPBRC_BAD_VERSION'    : 0,
  'OFPBRC_BAD_TYPE'       : 1,
  'OFPBRC_BAD_STAT'       : 2,
  'OFPBRC_BAD_VENDOR'     : 3,
  'OFPBRC_BAD_SUBTYPE'    : 4,
  'OFPBRC_EPERM'          : 5,
  'OFPBRC_BAD_LEN'        : 6,
  'OFPBRC_BUFFER_EMPTY'   : 7,
  'OFPBRC_BUFFER_UNKNOWN' : 8,
}
"""

ofp_bad_request_code_rev_map = {   #modify by Tan
  'OFPBRC_BAD_VERSION'    : 0,
  'OFPBRC_BAD_TYPE'       : 1,
  'OFPBRC_BAD_MULTIPART' : 2, 
  'OFPBRC_BAD_EXPERIMENTER': 3, 
  'OFPBRC_BAD_EXPERIMENTER_TYPE': 4,   
  'OFPBRC_EPERM': 5,
  'OFPBRC_BAD_LEN': 6, 
  'OFPBRC_BUFFER_EMPTY': 7,
  'OFPBRC_BUFFER_UNKNOWN': 8,
  'OFPBRC_BAD_TABLE_ID': 9,
  'OFPBRC_IS_SLAVE': 10,
  'OFPBRC_BAD_PORT': 11,
  'OFPBRC_BAD_PACKET': 12,
  'OFPBRC_MULTIPART_BUFFER_BUFFER_OVERFLOW': 13
} 

"""
ofp_bad_action_code_rev_map = {
  'OFPBAC_BAD_TYPE'        : 0,
  'OFPBAC_BAD_LEN'         : 1,
  'OFPBAC_BAD_VENDOR'      : 2,
  'OFPBAC_BAD_VENDOR_TYPE' : 3,
  'OFPBAC_BAD_OUT_PORT'    : 4,
  'OFPBAC_BAD_ARGUMENT'    : 5,
  'OFPBAC_EPERM'           : 6,
  'OFPBAC_TOO_MANY'        : 7,
  'OFPBAC_BAD_QUEUE'       : 8,
}
"""
ofp_bad_action_code_rev_map = {  #modify by Tan
  'OFPBAC_BAD_TYPE'        : 0,
  'OFPBAC_BAD_LEN'         : 1,
  'OFPBAC_BAD_EXPERIMENTER': 2, 
  'OFPBAC_BAD_EXPERIMENTER_TYPE': 3, 
  'OFPBAC_BAD_OUT_PORT': 4,  
  'OFPBAC_BAD_ARGUMENT': 5, 
  'OFPBAC_EPERM': 6, 
  'OFPBAC_TOO_MANY': 7, 
  'OFPBAC_BAD_QUEUE': 8,
  'OFPBAC_BAD_OUT_GROUP': 9,
  'OFPBAC_MATCH_INCONSISTENT': 10,
  'OFPBAC_UNSUPPORTED_ORDER': 11,
  'OFPBAC_BAD_TAG': 12,
  'OFPBAC_BAD_SET_TYPE': 13,
  'OFPBAC_BAD_SET_LEN': 14,
  'OFPBAC_BAD_SET_ARGUMENT': 15
}

ofp_bad_instruction_code_rev_map = {    #add by Tan
  'OFPBIC_UNKNOW_INST': 0,
  'OFPBIC_UNSUP_INST': 1,
  'OFPBIC_BAD_TABLE_ID': 2,
  'OFPBIC_UNSUP_METADATA': 3,
  'OFPBIC_UNSUP_METADATA_MASK': 4,    
  'OFPBIC_BAD_EXPERIMENTER': 5,
  'OFPBIC_BAD_EXPERIMENTER_TYPE': 6,
  'OFPBIC_BAD_LEN': 7,
  'OFPBIC_EPERM': 8,
  'OFPBIC_TOO_MANY_ACTIONS': 9                          
}

ofp_bad_match_code_rec_map = {      #add by Tan
  'OFPBMC_BAD_TYPE': 0,
  'OFPBMC_BAD_LEN': 1,
  'OFPBMC_BAD_TAG': 2,
  'OFPBMC_BAD_DL_ADDR_MASK': 3,
  'OFPBMC_BAD_NW_ADDR_MASK': 4,
  'OFPBMC_BAD_WILDCARD': 5,
  'OFPBMC_BAD_FIELD': 6,
  'OFPBMC_BAD_VALUE': 7,
  'OFPBMC_BAD_MASK': 8,
  'OFPBMC_BAD_PREERQ': 9,  
  'OFPBMC_DUP_FIELD': 10,
  'OFPBMC_RPERM': 11
}
"""
ofp_flow_mod_failed_code_rev_map = {
  'OFPFMFC_ALL_TABLES_FULL'   : 0,
  'OFPFMFC_OVERLAP'           : 1,
  'OFPFMFC_EPERM'             : 2,
  'OFPFMFC_BAD_EMERG_TIMEOUT' : 3,
  'OFPFMFC_BAD_COMMAND'       : 4,
  'OFPFMFC_UNSUPPORTED'       : 5,
}
"""
ofp_flow_mod_failed_code_rev_map = {   #modify by Tan
  'OFOFMFC_UNKNOWN': 0,
  'OFOFMFC_TABLE_FULL': 1,
  'OFOFMFC_BAD_TABLE_ID': 2,
  'OFPFMFC_OVERLAP': 3, 
  'OFPFMFC_EPERM': 4,       
  'OFPFMFC_BAD_TIMEOUT': 5, 
  'OFPFMFC_BAD_COMMAND': 6, 
  'OFOFMFC_BAD_FLAGS': 7
}

ofp_group_mod_failed_code_rev_map = {  #add by Tan
  'OFPGMFC_GROUP_EXISTS': 0,
  'OFPGMFC_INVALID_GROUP': 1,
  'OFPGMFC_WEIGHT_UNSUPPORTED': 2,
  'OFPGMFC_OUT_OF_GROUPS': 3,
  'OFPGMFC_OUT_OF_BUCKETS': 4,
  'OFPGMFC_CHAINING_UNSUPPORTED': 5,
  'OFPGMFC_WATCH_UNSUPPORTED': 6,
  'OFPGMFC_LOOP': 7,
  'OFPGMFC_UNKNOWN_GROUP': 8,
  'OFPGMFC_CHAINED_GROUP': 9,     
  'OFPGMFC_BAD_TYPE': 10,
  'OFPGMFC_BAD_COMMAND': 11,
  'OFPGMFC_BAD_BUCKET': 12,
  'OFPGMFC_BAD_WATCH': 13,
  'OFPGMFC_EPERM': 14
}

ofp_port_mod_failed_code_rev_map = {
  'OFPPMFC_BAD_PORT'    : 0,
  'OFPPMFC_BAD_HW_ADDR' : 1,
}

ofp_queue_op_failed_code_rev_map = {
  'OFPQOFC_BAD_PORT'  : 0,
  'OFPQOFC_BAD_QUEUE' : 1,
  'OFPQOFC_EPERM'     : 2,
}

ofp_meter_mod_failed_code_rev_map = {   #add by Tan
  'OFPMMFC_UNKNOWN': 0,
  'OFPMMFC__METER_EXISTS': 1,
  'OFPMMFC_INVALID_METER': 2,
  'OFPMMFC_UNKNOWN_METER': 3,
  'OFPMMFC_BAD_COMMAND': 4,       
  'OFPMMFC_BAD_FLAGS': 5,
  'OFPMMFC_BAD_RATE': 6,
  'OFPMMFC_BAD_BURST': 7,
  'OFPMMFC_BAD_BAND': 8,
  'OFPMMFC_BAD_BAND_VALUE': 9,  
  'OFPMMFC_OUT_OF_METERS': 10,
  'OFPMMFC_OUT_OF_BANDS': 11
}

ofp_software_failed_code_rev_map ={  #add by Tan
  'OFPSEC_OK': 0,
  'OFPSEC_ALLOCATE_RESOURCE_FAILURE': 0x5001,
  'OFPSEC_ADD_EXIST_FLOW': 0x5002,
  'OFPSEC_DELETE_UNEXIST_FLOW': 0x5003,
  'OFPSEC_COUNTER_REQUEST_FAILURE': 0x5004,
  'OFPSEC_DELETE_NOT_EMPTY_TABLE': 0x5005,
  'OFPSEC_INVALID_TABLE_TYPE': 0x6000,
  'OFPSEC_INVALID_KEY_LENGTH': 0x6001,
  'OFPSEC_INVALID_TABLE_SIZE': 0x6002,
  'OFPSEC_INVALID_MATCH_KEY': 0x6003,
  'OFPSEC_UNSUPPORT_INSTRUTION_LENGTH': 0x6004,
  'OFPSEC_UNSUPPORT_INSTRUTION_TYPE': 0x6005,
  'OFPSEC_UNSUPPORT_ACTION_LENGTH': 0x6006,
  'OFPSEC_UNSUPPORT_ACTION_TYPE': 0x6007,
  'OFPSEC_TABLE_NOT_CREATED': 0x6008,
  'OFPSEC_UNSUPPORT_COMMAND': 0x6009,
  'OFPSEC_UNSUPPORT_FLOW_TABLE_COMMAND': 0x600A,
  'OFPSEC_UPFORWARD_TOO_LARGE_PACKET': 0x600B,
  'OFPSEC_CREATE_SOCKET_FAILURE': 0x7001,
  'OFPSEC_CONNECT_SERVER_FAILURE': 0x7002,
  'OFPSEC_SEND_MSG_FAILURE': 0x7003,
  'OFPSEC_RECEIVE_MSG_FAILURE': 0x7004,
  'OFPSEC_WRONG_CHANNEL_STATE': 0x7005,
  'OFPSEC_WRITE_MSG_QUEUE_FAILURE': 0x7006,
  'OFPSEC_READ_MSG_QUEUE_FAILURE': 0x7007,
  'OFPSEC_MESSAGE_SIZE_TOO_BIG': 0x7008,
  'OFPSEC_IPC_SEND_FAILURE': 0x8001,
  'OFPSEC_CREATE_TASK_FAILURE': 0x8002,
  'OFPSEC_CREATE_MSGQUEUE_FAILURE': 0x8003,
  'OFPSEC_CREATE_TIMER_FAILURE': 0x8004,   
  'OFPSEC_ERROR': 0xffff
}



ofp_port_config_rev_map = {
  'OFPPC_PORT_DOWN'    : 1,
  'OFPPC_NO_STP'       : 2,
  'OFPPC_NO_RECV'      : 4,
  'OFPPC_NO_RECV_STP'  : 8,
  'OFPPC_NO_FLOOD'     : 16,
  'OFPPC_NO_FWD'       : 32,
  'OFPPC_NO_PACKET_IN' : 64,
}

ofp_port_state_rev_map = {  #modify by Tan
  #'OFPPS_STP_LISTEN'  : 0,
  'OFPPS_LINK_DOWN'   : 1,
  #'OFPPS_STP_LEARN'   : 256,
  #'OFPPS_STP_FORWARD' : 512,
  #'OFPPS_STP_BLOCK'   : 768,
  'OFPPS_BLOCKED'      : 2,
  'OFPPS_LIVE'         : 4

}
#OFPPS_STP_MASK        = 768

ofp_port_features_rev_map = {  #modify by Tan
  'OFPPF_10MB_HD'    : 1,
  'OFPPF_10MB_FD'    : 2,
  'OFPPF_100MB_HD'   : 4,
  'OFPPF_100MB_FD'   : 8,
  'OFPPF_1GB_HD'     : 16,
  'OFPPF_1GB_FD'     : 32,
  'OFPPF_10GB_FD'    : 64,
  '''
  'OFPPF_COPPER'     : 128,
  'OFPPF_FIBER'      : 256,
  'OFPPF_AUTONEG'    : 512,
  'OFPPF_PAUSE'      : 1024,
  'OFPPF_PAUSE_ASYM' : 2048,
  '''
  'OFPPF_40GB_FD'    : 128,
  'OFPPF_100GB_FD'   : 256,
  'OFPPF_1TB_FD'     : 512,
  'OFPPF_OTHER'      : 1024,
  'OFPPF_COPPER'     : 2048,
  'OFPPF_FIBER'      : 4096,
  'OFPPF_AUTONEG'    : 8192,
  'OFPPF_PAUSE'      : 16384,
  'OFPPF_PAUSE_ASYM' : 32768,
}

ofp_queue_properties_rev_map = {
  'OFPQT_MIN_RATE' : 0,
}
OFPQT_NONE         = 0


ofp_capabilities_rev_map = {   #modify by Tan
  'OFPC_FLOW_STATS'   : 1,
  'OFPC_TABLE_STATS'  : 2,
  'OFPC_PORT_STATS'   : 4,
  #'OFPC_STP'          : 8,
  'OFPC_GROUP_STATUS' : 8,
  'OFPC_RESERVED'     : 16,
  'OFPC_IP_REASM'     : 32,
  'OFPC_QUEUE_STATS'  : 64,
  'OFPC_ARP_MATCH_IP' : 128,
  'OFPC_PORT_BLOCKED' : 256
}

ofp_config_flags_rev_map = {
  'OFPC_FRAG_NORMAL' : 0,
  'OFPC_FRAG_DROP'   : 1,
  'OFPC_FRAG_REASM'  : 2,
  'OFPC_FRAG_MASK'   : 3,
}

ofp_flow_mod_command_rev_map = {
  'OFPFC_ADD'           : 0,
  'OFPFC_MODIFY'        : 1,
  'OFPFC_MODIFY_STRICT' : 2,
  'OFPFC_DELETE'        : 3,
  'OFPFC_DELETE_STRICT' : 4,
}

ofp_flow_mod_flags_rev_map = {
  'OFPFF_SEND_FLOW_REM' : 1,
  'OFPFF_CHECK_OVERLAP' : 2,
  'OFPFF_EMERG'         : 4,
}

ofp_stats_reply_flags_rev_map = {
  'OFPSF_REPLY_MORE' : 1,
}

ofp_packet_in_reason_rev_map = {
  'OFPR_NO_MATCH' : 0,
  'OFPR_ACTION'   : 1,
  'OFPR_INVALID_TTL' : 2      #add by Tan
}

ofp_flow_removed_reason_rev_map = {
  'OFPRR_IDLE_TIMEOUT' : 0,
  'OFPRR_HARD_TIMEOUT' : 1,
  'OFPRR_DELETE'       : 2,
}

ofp_port_reason_rev_map = {
  'OFPPR_ADD'    : 0,
  'OFPPR_DELETE' : 1,
  'OFPPR_MODIFY' : 2,
}

ofp_port_rev_map = {
  'OFPP_MAX'        : 65280,
  'OFPP_IN_PORT'    : 65528,
  'OFPP_TABLE'      : 65529,
  'OFPP_NORMAL'     : 65530,
  'OFPP_FLOOD'      : 65531,
  'OFPP_ALL'        : 65532,
  'OFPP_CONTROLLER' : 65533,
  'OFPP_LOCAL'      : 65534,
  'OFPP_NONE'       : 65535,
}

ofp_meter_mod_com_rev_map = {    #add by Tan
    'OFPMC_ADD' : 0,
    'OFPMC_MODIFY' : 1,
    'OFPMC_DELETE' : 2
}

ofp_counter_mod_com_rev_map = {   #add by Tan
    'OFPCC_ADD' : 0,
    'OFPCC_DELETE' : 1,
    'OFPCC_CLEAR' : 2,
    'OFPCC_QUERY' : 3                     
}

ofp_calc_type_rev_map = {    #add by Tan
  'OFPCT_ADD' : 0,
  'OFPCT_SUBTRACT' : 1,
  'OFPCT_LEFT_SHIFT' : 2,
  'OFPCT_RIGHT_SHIFT' : 3,
  'OFPCT_BITWISE_ADD' : 4,
  'OFPCT_BITWISE_OR' : 5,
  'OFPCT_BITWISE_XOR' : 6,
  'OFPCT_BITWISE_NOR' : 7,
}


ofp_drop_reason_rev_map = {    #add by Tan
  'OFPDT_TIMEOUT' : 0,
  'OFPDT_HIT_MISS' : 1,
  'OFPDT_UNKNOW'   : 2
}

ofp_group_type_rev_map={        #add by Tan
   'OFPGT_ALL'        :   0,
   'OFPGT_SELECT'     :   1,
   'OFPGT_INDIRECT'   :   2,
   'OFPGT_FF'         :   3
}

ofp_group_mod_cmd_rev_map={    #add by Tan
   'OFPGC_ADD'          :   0,
   'OFPGC_MODIFY'       :   1,
   'OFPGC_DELETE'       :   2
}

ofp_table_type_rev_map={        #add by milktank
   'OF_MM_TABLE'        :   0,
   'OF_LPM_TABLE'       :   1,
   'OF_EM_TABLE'        :   2,
   'OF_LINEAR_TABLE'    :   3,
   'OF_MAX_TABLE_TYPE'  :   4
}

ofp_table_mod_cmd_rev_map={    #add by milktank
   'OFPTC_ADD'          :   0,
   'OFPTC_MODIFY'       :   1,
   'OFPTC_DELETE'       :   2
}

ofp_meter_mod_cmd_rev_map = {    #add by Tan
    'OFPMC_ADD' : 0,
    'OFPMC_MODIFY' : 1,
    'OFPMC_DELETE' : 2
}

ofp_counter_mod_cmd_rev_map = {   #add by Tan
    'OFPCC_ADD'    : 1,
    'OFPCC_DELETE' : 2,
    'OFPCC_CLEAR'  : 3,
    'OFPCC_QUERY'  : 4                   
}
ofp_flow_wildcards_rev_map = {  #modify by Tan
  'OFPFW_IN_PORT'      : 1,
  'OFPFW_DL_VLAN'      : 2,
  'OFPFW_DL_SRC'       : 4,
  'OFPFW_DL_DST'       : 8,
  'OFPFW_DL_TYPE'      : 16,
  'OFPFW_NW_PROTO'     : 32,
  'OFPFW_TP_SRC'       : 64,
  'OFPFW_TP_DST'       : 128,
  'OFPFW_DL_VLAN_PCP'  : 1048576,
  'OFPFW_NW_TOS'       : 1<<21,
}


OFPFW_NW_DST_BITS      = 6
OFPFW_NW_SRC_BITS      = 6
OFPFW_NW_SRC_SHIFT     = 8
OFPFW_NW_DST_SHIFT     = 14
OFPFW_NW_SRC_ALL       = 8192
OFPFW_NW_SRC_MASK      = 16128
OFPFW_NW_DST_ALL       = 524288
OFPFW_NW_DST_MASK      = 1032192
# Note: Need to handle all flags that are set in this.
# glob-all masks in the packet handling methods.
# (Esp. ofp_match.from_packet)
# Otherwise, packets are not being matched as they should
OFPFW_ALL              = ((1 << 22) - 1)

NO_BUFFER = 4294967295


###the line below this is written by milktank
OFP_INVALID_VALUE = 0xFFFFFFFF     ## Define invalid value. {@value}.
OFP_NAME_MAX_LENGTH = 64           ## Define the length of device name.
OFP_ERROR_STRING_MAX_LENGTH = 256  ## Define the max length of error string.
OFP_PACKET_IN_MAX_LENGTH = 2048    ## Define the max length of packetin. {@value}.
OFP_MAX_FIELD_LENGTH_IN_BYTE = 16  ## Define the max length in byte unit of match field. {@value}.
OFP_MAX_MATCH_FIELD_NUM = 8        ## Define the max number of match field in one flow entry. {@value}.
OFP_MAX_INSTRUCTION_NUM = 6        ## Define the max instruction number of one flow entry. {@value}.
OFP_MAX_PROTOCOL_FIELD_NUM  = 8    ## Define the max field number of one protocol. {@value}.
OFP_MAX_ACTION_NUMBER_PER_INSTRUCTION = 6  ## Define the max action number in one instruction. {@value}.
OFP_MAX_ACTION_NUMBER_PER_GROUP = 6 ##Define the max action number in one group. {@value}.
OFP_MAX_ACTION_LENGTH = 44         ## Define the max action length in unit of byte. {@value}.
OFP_MAX_INSTRUCTION_LENGTH = (8 + 8 + OFP_MAX_ACTION_NUMBER_PER_INSTRUCTION * (OFP_MAX_ACTION_LENGTH + 4)) #Define the max instruction length in unit of byte. {@value}.


# --------------------------------------------------------------------

# ----------------------------------------------------------------------


# ----------------------------------------------------------------------
# Structure definitions
# ----------------------------------------------------------------------

#1. Openflow Header
class ofp_header (ofp_base):
  _MIN_LENGTH = 8
  def __init__ (self, **kw):
    self.version = OFP_VERSION
    #self.header_type = None # Set via class decorator
    self._xid = None
    if 'header_type' in kw:
      self.header_type = kw.pop('header_type')
    initHelper(self, kw)

  @property
  def xid (self):
    if self._xid is None:
      self._xid = generate_xid()
    return self._xid

  @xid.setter
  def xid (self, val):
    self._xid = val

  def _validate (self):
    if self.header_type not in ofp_type_map:
      return "type is not a known message type"
    return None

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!BBHL", self.version, self.header_type,
        len(self), self.xid)
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    return offset,length

  def _unpack_header (self, raw, offset):
    offset,(self.version, self.header_type, length, self.xid) = \
        _unpack("!BBHL", raw, offset)
    return offset,length

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.version != other.version: return False
    if self.header_type != other.header_type: return False
    if len(self) != len(other): return False
    if self.xid != other.xid: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'version: ' + str(self.version) + '\n'
    outstr += prefix + 'type:    ' + str(self.header_type)# + '\n'
    outstr += " (" + ofp_type_map.get(self.header_type, "Unknown") + ")\n"
    try:
      outstr += prefix + 'length:  ' + str(len(self)) + '\n'
    except:
      pass
    outstr += prefix + 'xid:     ' + str(self.xid) + '\n'
    return outstr
  
  def __str__ (self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

#   POF instruction Header by #milktank
class ofp_instruction (ofp_base):     #add by milktank
  """
    This class is generated by Milktank_tool 
    @author: milktank
    @version: 1.0
    @todo: ofp_instruction header

  """


  _MIN_LENGTH = 8
  _MAX_LENGTH = OFP_MAX_INSTRUCTION_LENGTH

  def __init__(self,**kw):
    #self.ofinstructionType = 0 set via class decorator
    #self.length = 0   ##would the length filed effect the length of the message ? ask: by milktank
    self.reserve = 0
    initHelper(self, kw)



  def __eq__(self,other):
    if type(self) != type(other): return False
    if self.ofinstructionType != other.ofinstructionType: return False
    if len(self) != len(other) : return False
    if self.reserve != other.reserve: return False
    return True


  def show(self,prefix=''):
    outstr =''
    outstr += prefix + 'ofinstructionType: '+  str(self.ofinstructionType) + '\n' 
    outstr += prefix + 'length: '+  str(len(self)) + '\n' 
    outstr += prefix + 'reserve: '+  str(self.reserve) + '\n' 
    return outstr



  def __repr__(self):
    return self.show()



  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()



  def __len__(self):
    return 8     ##Need to change to the correct length of the packet 



  def unpack(self,raw,offset=0):
    _offset = offset
    offset,self.ofinstructionType = _unpack('!H', raw, offset)
    offset,length = _unpack('!H', raw, offset)
    offset,self.reserve = _unpack('!L', raw, offset)
    assert offset - _offset == len(self)
    return offset



  def pack(self):
    assert self._assert()
    packed=b""
    packed += struct.pack("!H" ,self.ofinstructionType)
    packed += struct.pack("!H" ,len(self))
    packed += _PAD4
    return packed

#   POF action header by #milktank
class ofp_action (ofp_base):         #modify by milktank
  """
    This class is generated by Milktank_tool 
    @author: milktank
    @version: 1.0
    @todo: pof action_base class 

  """


  _MIN_LENGTH = 4
  _MAX_LENGTH = 4 + OFP_MAX_ACTION_LENGTH

  def __init__(self,**kw):
    #self.ofActionType = 0 #set type in class decorator
    #self.length = 0  ##should is be delete?
    initHelper(self, kw)



  def __eq__(self,other):
    if type(self) != type(other): return False
    if self.ofActionType != other.ofActionType: return False
    if len(self) != len(other): return False
    return True


  def show(self,prefix=''):
    outstr =''
    outstr += prefix + 'ofActionType: '+  str(self.ofActionType) + '\n' 
    outstr += prefix + 'length: '+  str(len(self)) + '\n' 
    return outstr



  def __repr__(self):
    return self.show()



  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()



  def __len__(self):
    return 4     ##Need to change to the correct length of the packet 



  def unpack(self,raw,offset=0):
    _offset = offset
    offset,self.ofActionType = _unpack('!H', raw, offset)
    offset,length = _unpack('!H', raw, offset)
    assert offset - _offset == len(self)
    return offset



  def pack(self):
    assert self._assert()
    packed=b""
    packed += struct.pack("!H" ,self.ofActionType)
    packed += struct.pack("!H" ,len(self))
    return packed
 

class ofp_stats_body_base (ofp_base):
  """
  Base class for stats bodies
  """
  # Stats bodies don't actually have a type field in OpenFlow --
  # the type information is in the request or reply.  It's really
  # convenient, though, so we add it.  Note that you generally
  # don't need to set this yourself -- the openflow_stats_XXX
  # decorator will do it for you.
  _type = None

  """
  def unpack (self, data, offset=0, avail=None):
  """

class ofp_action_base (ofp_base):
  """
  Base class for actions

  This is sort of the equivalent of ofp_action_header in the spec.
  However, ofp_action_header as the spec defines it is not super
  useful for us, as it has the padding in it.
  """
  type = None


class ofp_queue_prop_base (ofp_base):
  """
  Base class for queue properties

  This is sort of the equivalent of ofp_queue_prop_header in the spec.
  However, ofp_queue_prop_header as the spec defines it is not super
  useful for us, as it has the padding in it.
  """
  property = None


#2. Common Structures
##2.1 Port Structures
class ofp_phy_port (ofp_base):  #modify by milktank
  """
    @author: milktank
    @version:1.0
    @edit_time:2014-10-3 14:06:21
    @contact: change structure to  adapt the POF
  """
  _MIN_LENGTH = 88
  OFP_ETH_ALEN = 6
  def __init__ (self, **kw):
    self.port_no = 0
    self.deviceId=0
    self.hardwareAddress = EMPTY_ETH
    self.reserve2=[]
    self.name = ""
    self.config = 0
    self.state = 0
    self.currentFeatures = 0
    self.advertisedFeatures = 0
    self.supportedFeatures = 0
    self.peerFeatures = 0
    self.currentSpeed=0
    self.maxSpeed=0
    self.openflowEnable=0  ##???????
    self.reserve7=[]
    initHelper(self, kw)

  def enable_config (self, mask):
    """
    Turn on selected config bits
    """
    return self.set_config(0xffFFffFF, mask)

  def disable_config (self, mask):
    """
    Turn off selected config bits
    """
    return self.set_config(0, mask)

  def set_config (self, config, mask):
    """
    Updates the specified config bits

    Returns which bits were changed
    """
    old = self.config
    self.config &= ~mask
    self.config |= config
    return old ^ self.config

  def __str__ (self):
    return "%s:%i" % (self.name, self.portId)

  def _validate (self):
    if isinstance(self.hardwareAddress, bytes) and len(self.hardwareAddress) == 6:
      pass
    elif not isinstance(self.hardwareAddress, EthAddr):
      return "hw_addr is not a valid format"
    if len(self.name) > OFP_MAX_PORT_NAME_LEN:
      return "name is too long"
    return None

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack ( "!L" ,self.portId)
    packed += struct.pack ( "!L" ,self.deviceId)

    packed += (self.hardwareAddress if isinstance(self.hardwareAddress, bytes) else
               self.hardwareAddress.toRaw())
    packed += _PAD2
    
    #packed += self.name.ljust(OFP_MAX_PORT_NAME_LEN,'\0')
    packed += struct.pack ( "!64s" ,self.name)
    packed += struct.pack ( "!L" ,self.config)
    packed += struct.pack ( "!L" ,self.state)
    packed += struct.pack ( "!L" ,self.currentFeatures)
    packed += struct.pack ( "!L" ,self.advertisedFeatures)
    packed += struct.pack ( "!L" ,self.supportedFeatures)
    packed += struct.pack ( "!L" ,self.peerFeatures)
    packed += struct.pack ( "!L" ,self.currentSpeed)
    packed += struct.pack ( "!L" ,self.maxSpeed)
    packed += struct.pack ( "!B" ,self.openflowEnable)
    packed += _PAD*7
    return packed
 
  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.portId,self.deviceId) = _unpack("!LL", raw, offset)
    offset,self.hardwareAddress = _readether(raw, offset) 
    for i in xrange(0,2):
        offset,(tempresver,)=_unpack("!B", raw, offset)
        self.reserve2.append(tempresver)
    #offset = _skip(raw, offset, 2)    

    offset,self.name = _readzs(raw, offset, OFP_MAX_PORT_NAME_LEN)
    offset,(self.config, self.state, self.currentFeatures, self.advertisedFeatures,
            self.supportedFeatures, self.peerFeatures) = _unpack("!LLLLLL", raw, offset)
    offset,(self.currentSpeed,self.maxSpeed,self.openflowEnable) = _unpack("!LLB", raw, offset)
    for i in xrange(0,7):
        offset,(tempresver,)=_unpack("!B", raw, offset)
        self.reserve7.append(tempresver)
    #offset = _skip(raw, offset, 7)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 120

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.portId != other.portId: return False
    if self.deviceId != other.deviceId: return False
    if self.hardwareAddress != other.hardwareAddress: return False
    if self.name != other.name: return False
    if self.config != other.config: return False
    if self.state != other.state: return False
    if self.currentFeatures != other.currentFeatures: return False
    if self.advertisedFeatures != other.advertisedFeatures: return False
    if self.supportedFeatures != other.supportedFeatures: return False
    if self.peerFeatures != other.peerFeatures: return False
    if self.currentSpeed != other.currentSpeed: return False
    if self.maxSpeed != other.maxSpeed: return False
    if self.openflowEnable != other.openflowEnable: return False
    if self.reserve2 != other.reserve2: return False
    if self.reserve7 != other.reserve7: return False
    
    
    return True

  def __cmp__ (self, other):
    if type(other) != type(self): return id(self)-id(other)
    if self.portId < other.portId: return -1
    if self.portId > other.portId: return 1
    if self == other: return 0
    return id(self)-id(other)
  
  def __hash__(self, *args, **kwargs):
    return hash(self.portId) ^ hash(self.deviceId) ^ hash(self.hardwareAddress) ^ \
           hash(self.name) ^ hash(self.config) ^ \
           hash(self.state) ^ hash(self.currentFeatures) ^ \
           hash(self.advertisedFeatures) ^ hash(self.supportedFeatures) + \
           hash(self.peerFeatures)   ####????POF :is it enough to get hash value?

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'portId: ' + str(self.portId) + '\n'
    outstr += prefix + 'deviceId: ' + str(self.deviceId) + '\n'
    outstr += prefix + 'hardwareAddress: ' + str(EthAddr(self.hardwareAddress)) + '\n'
    outstr += prefix + 'name: ' + str(self.name) + '\n'
    outstr += prefix + 'config: ' + str(self.config) + '\n'
    outstr += prefix + 'state: ' + str(self.state) + '\n'
    outstr += prefix + 'currentFeatures: ' + str(self.currentFeatures) + '\n'
    outstr += prefix + 'advertisedFeatures: ' + str(self.advertisedFeatures) + '\n'
    outstr += prefix + 'supportedFeatures: ' + str(self.supportedFeatures) + '\n'
    outstr += prefix + 'peerFeatures: ' + str(self.peerFeatures) + '\n'
    outstr += prefix + 'currentSpeed: ' + str(self.currentSpeed) + '\n'
    outstr += prefix + 'maxSpeed: ' + str(self.maxSpeed) + '\n'
    outstr += prefix + 'openflowEnable: ' + str(self.openflowEnable) + '\n'

    return outstr

  def __repr__(self):
    return self.show()


##2.2 Queue Structures
class ofp_packet_queue (ofp_base):
  _MIN_LENGTH = 8
  def __init__ (self, **kw):
    self.queue_id = 0
    self.properties = []

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!LH", self.queue_id, len(self))
    packed += _PAD2 # Pad
    for i in self.properties:
      packed += i.pack()
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.queue_id, length) = _unpack("!LH", raw, offset)
    offset = _skip(raw, offset, 2)
    length -= (4 + 2 + 2)

    offset,self.properties = _unpack_queue_props(raw, length, offset)

    assert offset - _offset == len(self)
    return offset

  def __len__ (self):
    l = 8
    for i in self.properties:
      l += len(i)
    return l

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.queue_id != other.queue_id: return False
    if len(self) != len(other): return False
    if self.properties != other.properties: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'queue_id: ' + str(self.queue_id) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'properties: \n'
    for obj in self.properties:
      outstr += obj.show(prefix + '  ')
    return outstr


class ofp_queue_prop_generic (ofp_queue_prop_base):
  _MIN_LENGTH = 8
  def __init__ (self, **kw):
    self.property = None # Purposely bad
    self.data = _PAD4

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!HH", self.property, len(self))
    packed += self.data
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.property, length) = _unpack("!HH", raw, offset)
    offset,self.data = _read(raw, offset, length-4)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 4 + len(self.data)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.property != other.property: return False
    if len(self) != len(other): return False
    if self.data != other.data: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'property: ' + str(self.property) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    return outstr


@openflow_queue_prop('OFPQT_NONE', 0)
class ofp_queue_prop_none (ofp_queue_prop_generic):
  pass


@openflow_queue_prop('OFPQT_MIN_RATE', 1)
class ofp_queue_prop_min_rate (ofp_base):
  def __init__ (self, **kw):
    self.rate = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!HH", self.property, len(self))
    packed += _PAD4
    packed += struct.pack("!H", self.rate)
    packed += _PAD6
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.property, length, pad) = \
        _unpack("!HHL", raw, offset)
    offset,(self.rate,) = _unpack("!H", raw, offset)
    offset = _skip(raw, offset, 6)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 16

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.property != other.property: return False
    if self.rate != other.rate: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'property: ' + str(self.property) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'rate: ' + str(self.rate) + '\n'
    return outstr


##2.3 Flow Match Structures
class ofp_match(ofp_base):    #modify by Tan
  _MIN_LENGTH = 40
  def __init__(self,  **kw):
    self.wildcards = 0
    self.inputPort = 0   #array  reserve[3]
    self.dataLayerSrc = 0
    self.dataLayerDes = 0
    self.dataLayerVirLan = 0
    self.dataLayerVirLanPriCodePoint = 0
    self.pad1 = 0
    self.dataLayerType = 0
    self.networkTypeOfService = 0
    self.networkPtotocol = 0
    self.pad2 = 0
    self.networkSrc = 0
    self.networkDes = 0
    self.transportSrc = 0
    self.transportDes = 0
    
    initHelper(self, kw)

  def pack (self):
    assert self._assert()
    packed = b""
    packed += struct.pack("!LH", self.wildcards, self.inputPort)
    packed += _PAD6
    packed += _PAD6
    packed += struct.pack("!HB", self.dataLayerVirLan, self.dataLayerVirLanPriCodePoint)
    packed += _PAD
    packed += struct.pack("!HBB", self.dataLayerType, self.networkTypeOfService, self.networkPtotocol)
    packed += _PAD2
    packed += struct.pack("!LLHH", self.networkSrc, self.networkDes, self.transportSrc, self.transportDes)
    return packed

  def unpack (self, raw, offset=0):
    offset,(self.wildcards, self.inputPort) = _unpack("!LH", raw, offset)
    offset = _skip(raw, offset, 6)
    offset = _skip(raw, offset, 6)
    offset,(self.dataLayerVirLan, self.dataLayerVirLanPriCodePoint) = _unpack("!HB", raw, offset)
    offset = _skip(raw, offset, 1)
    offset,(self.dataLayerType, self.networkTypeOfService, self.networkPtotocol) = _unpack("!HBB", raw, offset)
    offset = _skip(raw, offset, 2)
    offset,(self.networkSrc, self.networkDes, self.transportSrc, self.transportDes) = _unpack("!LLHH", raw, offset)
    return offset

  def __len__ (self):
    return 40

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.wildcards != other.wildcards: return False
    if self.inputPort != other.inputPort: return False
    if self.dataLayerSrc != other.dataLayerSrc: return False
    if self.dataLayerDes != other.dataLayerDes: return False
    if self.dataLayerVirLan != other.dataLayerVirLan: return False
    if self.dataLayerVirLanPriCodePoint != other.dataLayerVirLanPriCodePoint: return False
    if self.pad1 != other.pad1: return False
    if self.dataLayerType != other.dataLayerType: return False
    if self.networkTypeOfService != other.networkTypeOfService: return False
    if self.networkPtotocol != other.networkPtotocol: return False
    if self.pad2 != other.pad2: return False
    if self.networkSrc != other.networkSrc: return False
    if self.networkDes != other.networkDes: return False
    if self.transportSrc != other.transportSrc: return False
    if self.transportDes != other.transportDes: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'wildcards: ' + str(self.wildcards) + '\n'
    outstr += prefix + 'inputPort: ' + str(self.inputPort) + '\n'
    outstr += prefix + 'dataLayerSrc: ' + str(self.dataLayerSrc) + '\n'
    outstr += prefix + 'dataLayerDes: ' + str(self.dataLayerDes) + '\n'
    outstr += prefix + 'dataLayerVirLan: ' + str(self.dataLayerVirLan) + '\n'
    outstr += prefix + 'dataLayerVirLanPriCodePoint: \n'+ str(self.dataLayerVirLanPriCodePoint) + '\n'
    outstr += prefix + 'pad1: ' + str(self.pad1) + '\n'
    outstr += prefix + 'dataLayerType: ' + str(self.dataLayerType) + '\n'
    outstr += prefix + 'networkTypeOfService: ' + str(self.networkTypeOfService) + '\n'
    outstr += prefix + 'networkPtotocol: ' + str(self.networkPtotocol) + '\n'
    outstr += prefix + 'pad2: ' + str(self.pad2) + '\n'
    outstr += prefix + 'networkSrc: \n' + str(self.networkSrc) + '\n'
    outstr += prefix + 'networkDes: ' + str(self.networkDes) + '\n'
    outstr += prefix + 'transportSrc: ' + str(self.transportSrc) + '\n'
    outstr += prefix + 'transportDes: ' + str(self.transportDes) + '\n'
    return outstr



#2.4 ofp_table_resource Structures
class ofp_table_resource(ofp_base):   #add by milktank
  """
  @author: milktank
  @contact: ofp_table_resource class
              Using in the Msg:pof_resource_report->flowTableResource
  @version:1.0
  @edit_time:2014-10-1 14:44:11
              """
  _MIN_LENGTH = 16
  def __init__ (self, **kw):
    self.deviceId = 0
    self.ofTableType = 0
    self.tableNum = 0
    self.keyLength = 0
    self.totalSize = 0
    self.reserve=0    
    initHelper(self, kw)
  
  def pack (self):
    assert self._assert()
    packed = b""
    packed += struct.pack("!LBBHLL", self.deviceId, self.ofTableType, \
                self.tableNum, self.keyLength, self.totalSize, self.reserve)
    return packed 

  def unpack (self, raw, offset=0):
    offset,(self.deviceId,self.ofTableType,self.tableNum,self.keyLength,self.totalSize,self.reserve) = \
        _unpack("!LBBHLL", raw, offset)        

    return offset

  def __len__ (self):
    return 16
    #return 32 + len(self.ports) * len(ofp_phy_port)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    #if not ofp_header.__eq__(self, other): return False
    if self.deviceId != other.deviceId: return False
    if self.ofTableType != other.ofTableType: return False
    if self.tableNum != other.tableNum: return False
    if self.keyLength != other.keyLength: return False
    if self.totalSize != other.totalSize: return False
    if self.reserve != other.reserve: return False
    
    return True

  def show (self, prefix=''):
    outstr = ''
    #outstr += prefix + 'header: \n'
    #outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'deviceId: ' + str(self.deviceId) + '\n'
    outstr += prefix + 'ofTableType: ' + str(self.ofTableType) + '\n'
    outstr += prefix + 'tableNum: ' + str(self.tableNum) + '\n'
    outstr += prefix + 'keyLength: ' + str(self.keyLength) + '\n'
    outstr += prefix + 'totalSize: ' + str(self.totalSize) + '\n'
    outstr += prefix + 'reserve: ' + str(self.reserve) + '\n'        
    return outstr
    

##2.5 ofp_flow_table_resource Structures
class ofp_flow_table_resource(ofp_base):   #add by Tan
  #_MIN_LENGTH = 8
  def __init__(self,  **kw):
    self.resourceType = 0
    self.reserve = 0   #array  reserve[3]
    self.counterNum = 0
    self.meterNum = 0
    self.groupNum = 0
    self.tableResourceList = []    
    
    initHelper(self, kw)

  def pack (self):
    assert self._assert()
    packed = b""
    packed += struct.pack("!B", self.resourceType)
    #for i in self.reserveList:
      #packed += i.pack()
    packed += _PAD3
    packed += struct.pack("!LLL", self.counterNum, self.meterNum, self.groupNum)
    for j in self.tableResourceList:
      packed += j.pack()
    return packed

  def unpack (self, raw, offset=0):
    offset,(self.resourceType) = _unpack("!B", raw, offset)
    offset = _skip(raw, offset, 3)
    offset,(self.counterNum,  self.meterNum, self.groupNum) = _unpack("!LLL", raw, offset)
    tableCount = (self.counterNum / 8) / len(ofp_table_resource)
    self.tableResourceList = []
    for i in xrange(0, tableCount):
      p = ofp_table_resource()
      offset = p.unpack(raw, offset)
      self.tableResourceList.append(p)
    return offset

  def __len__ (self):
    #print ('len(self.tableResourceList)+++++++++++++++++++++', len(self.tableResourceList))
    return 16 + len(self.tableResourceList) * len(ofp_table_resource)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.resourceType != other.resourceType: return False
    if self.counterNum != other.counterNum: return False
    if self.meterNum != other.meterNum: return False
    if self.groupNum != other.groupNum: return False
    if self.tableResourceList != other.tableResourceList: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'resourceType: ' + str(self.resourceType) + '\n'
    outstr += prefix + 'reserve: ' + str(self.reserve) + '\n'
    outstr += prefix + 'counterNum: ' + str(self.counterNum) + '\n'
    outstr += prefix + 'meterNum: ' + str(self.meterNum) + '\n'
    outstr += prefix + 'groupNum: ' + str(self.groupNum) + '\n'
    outstr += prefix + 'tableResource: \n'
    for obj in self.tableResourceList:
      outstr += obj.show(prefix + '  ')
    return outstr


##2.6 ofp_match20 BY #milktank

class ofp_match20 (ofp_base):    #add by milktank
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """


  _MIN_LENGTH = 8


  def __init__(self,**kw):
    self.fieldname=""
    self.fieldId = 0
    self.offset = 0
    self.length = 0
    initHelper(self, kw)



  def __eq__(self,other):
    if type(self) != type(other): return False
    if self.fieldId != other.fieldId: return False
    if self.offset != other.offset: return False
    if self.length != other.length: return False
    return True


  def show(self,prefix=''):
    outstr =''
    outstr += prefix + 'fieldId: '+  str(self.fieldId) + '\n' 
    outstr += prefix + 'offset: '+  str(self.offset) + '\n' 
    outstr += prefix + 'length: '+  str(self.length) + '\n' 
    return outstr



  def __repr__(self):
    return self.show()



  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()



  def __len__(self):
    return 8     ##Need to change to the correct length of the packet 



  def unpack(self,raw,offset=0):
    _offset = offset
    offset,self.fieldId = _unpack('!H', raw, offset)
    offset,self.offset = _unpack('!H', raw, offset)
    offset,self.length = _unpack('!H', raw, offset)
    offset =_skip(raw, offset, 2)
    assert offset - _offset == len(self)
    return offset



  def pack(self):
    assert self._assert()
    packed=b""
    packed += struct.pack("!H" ,self.fieldId)
    packed += struct.pack("!H" ,self.offset)
    packed += struct.pack("!H" ,self.length)
    packed += _PAD2
    return packed

init_match20 = ofp_match20()


    
##2.7 ofp_flow_table by #milktank
class ofp_flow_table (ofp_base):  #add by milktank
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """


  _MIN_LENGTH = OFP_NAME_MAX_LENGTH + 16
  _MAX_LENGTH = OFP_NAME_MAX_LENGTH + 16 + OFP_MAX_MATCH_FIELD_NUM *  ofp_match20._MIN_LENGTH

  def __init__(self,**kw):
    self.command = 0  #OFPTC_ADD
    self.tableId = 0
    self.tableType = 0
    self.matchFieldNum = 0
    self.tableSize = 0
    self.keyLength = 0
    self.tableName = ""
    self.matchFieldList = []
    initHelper(self, kw)



  def __eq__(self,other):
    if type(self) != type(other): return False
    if self.command != other.command: return False
    if self.tableId != other.tableId: return False
    if self.tableType != other.tableType: return False
    if self.matchFieldNum != other.matchFieldNum: return False
    if self.tableSize != other.tableSize: return False
    if self.keyLength != other.keyLength: return False
    if self.tableName != other.tableName: return False
    if self.matchFieldList != other.matchFieldList: return False
    return True


  def show(self,prefix=''):
    outstr =''
    outstr += prefix + 'command: '+  str(self.command) + '\n' 
    outstr += prefix + 'tableId: '+  str(self.tableId) + '\n' 
    outstr += prefix + 'tableType: '+  str(self.tableType) + '\n' 
    outstr += prefix + 'matchFieldNum: '+  str(self.matchFieldNum) + '\n' 
    outstr += prefix + 'tableSize: '+  str(self.tableSize) + '\n' 
    outstr += prefix + 'keyLength: '+  str(self.keyLength) + '\n' 
    outstr += prefix + 'tableName: '+  str(self.tableName) + '\n' 
    outstr += prefix + 'matchFieldList: '+  str(self.matchFieldList) + '\n' 
    return outstr



  def __repr__(self):
    return self.show()



  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()



  def __len__(self):
    return ofp_flow_table._MAX_LENGTH     ##Need to change to the correct length of the packet 



  def unpack(self,raw,offset=0):
    _offset = offset
    offset,self.command = _unpack('!B', raw, offset)
    offset,self.tableId = _unpack('!B', raw, offset)
    offset,self.tableType = _unpack('!B', raw, offset)
    offset,self.matchFieldNum = _unpack('!B', raw, offset)
    offset,self.tableSize = _unpack('!L', raw, offset)
    offset,self.keyLength = _unpack('!H', raw, offset)
    
    offset = _skip(raw , offset, 6)
    
    offset,self.tableName = _unpack('!64s', raw, offset)
    for i in xrange(0,OFP_MAX_MATCH_FIELD_NUM):
        temp_matchFieldList=ofp_match20()
        offset = temp_matchFieldList.unpack(raw,offset)
        self.matchFieldList.append(temp_matchFieldList)
    assert offset - _offset == len(self)
    return offset



  def pack(self):
    assert self._assert()
    packed=b""
    packed += struct.pack("!B" ,self.command)
    #print (packed.encode('hex'))
    packed += struct.pack("!B" ,self.tableId)
    #print (packed.encode('hex'))
    packed += struct.pack("!B" ,self.tableType)
    #print (packed.encode('hex'))
    packed += struct.pack("!B" ,len(self.matchFieldList))
    #print (packed.encode('hex'))
    packed += struct.pack("!L" ,self.tableSize)
    #print (packed.encode('hex'))
    packed += struct.pack("!H" ,self.keyLength)
    #print (packed.encode('hex'))
    packed += _PAD6
    #print (packed.encode('hex'))
    packed += struct.pack("!64s" ,self.tableName)
    #print (packed.encode('hex'))
    numcount = 0
    for i in self.matchFieldList:
        packed += i.pack()
        numcount = numcount + 1
    if numcount < OFP_MAX_MATCH_FIELD_NUM:
        packed += _PAD*((OFP_MAX_MATCH_FIELD_NUM - numcount )*(ofp_match20._MIN_LENGTH))
    
    #print (packed.encode('hex'))    
    return packed



## 2.8 ofp_matchx #by milktank 
class ofp_matchx (ofp_base):    #add by milktank
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  def set_value(self,hexstring):
#     if not isdigit(hexstring):
#         print ("hexstring can't change to ")
#         return 0
    if (len(hexstring)%2):
        hexstring +='0'
    if (len(hexstring)>OFP_MAX_FIELD_LENGTH_IN_BYTE*2 ):
        hexstring=hexstring[:OFP_MAX_FIELD_LENGTH_IN_BYTE*2]
    self.value=[]
    
    
    for i in xrange(0,len(hexstring)/2):
        int_c=int(hexstring[i*2:i*2+2],16)    
        #print (hexstring[i*2:i*2+2]),int_c
        self.value.append(int_c)
        
  def set_mask(self,hexstring):
#     if not isdigit(hexstring):
#         print ("hexstring can't change to ")
#         return 0
    if (len(hexstring)%2):
        hexstring +='0'
    if (len(hexstring)>OFP_MAX_FIELD_LENGTH_IN_BYTE*2 ):
        hexstring=hexstring[:OFP_MAX_FIELD_LENGTH_IN_BYTE*2]
    self.mask=[]
    
    
    for i in xrange(0,len(hexstring)/2):
        int_c=int(hexstring[i*2:i*2+2],16)    
        #print (hexstring[i*2:i*2+2]),int_c
        self.mask.append(int_c)

  _MIN_LENGTH = 40
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    self.fieldId = 0
    self.offset = 0
    self.length = 0
    self.padding = 0
    self.value = []
    self.mask = []
    self.set_mask("00")
    self.set_value("00")
    initHelper(self, kw)



  def __eq__(self,other):
    if type(self) != type(other): return False
    if self.fieldId != other.fieldId: return False
    if self.offset != other.offset: return False
    if self.length != other.length: return False
    if self.padding != other.padding: return False
    if self.value != other.value: return False
    if self.mask != other.mask: return False
    return True


  def show(self,prefix=''):
    outstr =''
    outstr += prefix + 'fieldId: '+  str(self.fieldId) + '\n' 
    outstr += prefix + 'offset: '+  str(self.offset) + '\n' 
    outstr += prefix + 'length: '+  str(self.length) + '\n' 
    outstr += prefix + 'padding: '+  str(self.padding) + '\n' 
    outstr += prefix + 'value: '+  str(self.value) + '\n' 
    outstr += prefix + 'mask: '+  str(self.mask) + '\n' 
    return outstr



  def __repr__(self):
    return self.show()



  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()



  def __len__(self):
    return 40     ##Need to change to the correct length of the packet 



  def unpack(self,raw,offset=0):
    _offset = offset
    offset,self.fieldId = _unpack('!H', raw, offset)
    offset,self.offset = _unpack('!H', raw, offset)
    offset,self.length = _unpack('!H', raw, offset)
    offset,self.padding = _unpack('!H', raw, offset)
    for i in xrange(0,16):
            offset,temp_value = _unpack('!B', raw, offset)
            self.value.append(temp_value)
    for i in xrange(0,16):
            offset,temp_mask = _unpack('!B', raw, offset)
            self.mask.append(temp_mask)
    assert offset - _offset == len(self)
    return offset



  def pack(self):
    assert self._assert()
    packed=b""
    packed += struct.pack("!H" ,self.fieldId)
    packed += struct.pack("!H" ,self.offset)
    packed += struct.pack("!H" ,self.length)
    packed += struct.pack("!H" ,self.padding)
    for i in self.value:
        packed += struct.pack("!B" ,i)
    packed += _PAD*(OFP_MAX_FIELD_LENGTH_IN_BYTE - len(self.value))
    
    for i in self.mask:
        packed += struct.pack("!B" ,i)
    packed += _PAD*(OFP_MAX_FIELD_LENGTH_IN_BYTE - len(self.mask))
    return packed


"""
    @author: milktank
    @todo: define the POF action struct
    @version: 1.0
    @time: 2014-10-10 18:51:27
    @list: 
    ## action 0  OUTPUT 
    ## action 1  SET_FIELD
    ## action 2  SET_FIELD_FROM_METADATA       
    ## action 3  MODIFY_FIELD  
    ## action 4  ADD_FIELD      
    ## action 5  DELETE_FIELD        
    ## action 6  CALCULATE_CHECKSUM  
    ## action 7  GROUP   
    ## action 8  GROUP     
    ## action 9  PACKET_IN           
    ## action 9  COUNTER
    ## action 10 EXPERIMENTER                  
 
"""

## action 0  OUTPUT 
@openflow_action("OUTPUT", 0)
class ofp_action_output (ofp_action):
  """
    This class is generated by Milktank_tool e
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_action._MIN_LENGTH + 16
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_action.__init__(self)
    self.portIdValueType = 0
    self.metadataOffset = 0
    self.metadataLength = 0
    self.packetOffset = 0
    self.portId = 0
    self.portIdField = ofp_match20()
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_action.__eq__(self, other) : return False
    if self.portIdValueType != other.portIdValueType: return False
    if self.metadataOffset != other.metadataOffset: return False
    if self.metadataLength != other.metadataLength: return False
    if self.packetOffset != other.packetOffset: return False
    if self.portId != other.portId: return False
    if self.portIdField != other.portIdField: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_action.show(self, prefix + '  ')
    outstr += prefix + 'portIdValueType: '+  str(self.portIdValueType) + '\n' 
    outstr += prefix + 'metadataOffset: '+  str(self.metadataOffset) + '\n' 
    outstr += prefix + 'metadataLength: '+  str(self.metadataLength) + '\n' 
    outstr += prefix + 'packetOffset: '+  str(self.packetOffset) + '\n' 
    outstr += prefix + 'portId: '+  str(self.portId) + '\n'  
    outstr += prefix + 'portIdField: \n' 
    outstr += self.portIdField.show(prefix + '  ')
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_action_output._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_action.unpack(raw,offset)
    offset,self.portIdValueType = _unpack('!B', raw, offset)
    offset = _skip(raw, offset, 1)
    offset,self.metadataOffset = _unpack('!H', raw, offset)
    offset,self.metadataLength = _unpack('!H', raw, offset)
    offset,self.packetOffset = _unpack('!H', raw, offset)  
    offset,self.portId = _unpack('!L', raw, offset)
    offset=self.portIdField.unpack(raw, offset)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_action.pack(self)
    packed += struct.pack("!B" ,self.portIdValueType)
    packed += _PAD
    packed += struct.pack("!H" ,self.metadataOffset)
    packed += struct.pack("!H" ,self.metadataLength)
    packed += struct.pack("!H" ,self.packetOffset)
    if self.portIdValueType==0:
        packed += struct.pack("!L" ,self.portId)
        packed += _PAD4
    elif self.portIdValueType==1 and self.portIdField !=ofp_match20():
        packed += self.portIdField.pack()
    else:
        packed += _PAD*ofp_match20._MIN_LENGTH
    return packed

## action 1  SET_FIELD
@openflow_action("SET_FIELD", 1)
class ofp_action_setfield (ofp_action):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_action._MIN_LENGTH + ofp_matchx._MIN_LENGTH
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_action.__init__(self)
    self.fieldSetting = ofp_matchx()
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_action.__eq__(self, other) : return False
    if self.fieldSetting != other.fieldSetting: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_action.show(self, prefix + '  ')
    outstr += prefix + 'fieldSetting: \n' 
    outstr += self.fieldSetting.show(prefix + '  ') 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_action_setfield._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_action.unpack(raw,offset)
    offset=self.fieldSetting.unpack(raw, offset)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_action.pack(self)
    packed += self.fieldSetting.pack()
    return packed


## action 2  SET_FIELD_FROM_METADATA     
@openflow_action("SET_FIELD_FROM_METADATA", 2)
class ofp_action_setfieldfrommetadata (ofp_action):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_action._MIN_LENGTH + ofp_match20._MIN_LENGTH + 8
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_action.__init__(self)
    self.fieldsetting = ofp_match20()
    self.metadataoffset = 0
    #self.padding = []
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_action.__eq__(self, other) : return False
    if self.fieldsetting != other.fieldsetting: return False
    if self.metadataoffset != other.metadataoffset: return False
    #if self.padding != other.padding: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_action.show(self, prefix + '  ')
    outstr += prefix + 'fieldSetting: \n' 
    outstr += self.fieldSetting.show(prefix + '  ')  
    outstr += prefix + 'metadataoffset: '+  str(self.metadataoffset) + '\n' 
    #outstr += prefix + 'padding: '+  str(self.padding) + '\n' 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_action_setfieldfrommetadata._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_action.unpack(raw,offset)
    offset=self.fieldsetting.unpack(raw, offset)
    offset,self.metadataoffset = _unpack('!H', raw, offset)
    offset=_skip(raw, offset, 6)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_action.pack(self)
    packed += self.fieldsetting.pack()
    packed += struct.pack("!H" ,self.metadataoffset)
    packed += _PAD6
    return packed

  
## action 3  MODIFY_FIELD
@openflow_action("MODIFY_FIELD", 3)
class ofp_action_modifyfield (ofp_action):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_action._MIN_LENGTH + ofp_match20._MIN_LENGTH + 8
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_action.__init__(self)
    self.matchfield = ofp_match20()
    self.increment = 0
#     self.reserve = []
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_action.__eq__(self, other) : return False
    if self.matchfield != other.matchfield: return False
    if self.increment != other.increment: return False
#     if self.reserve != other.reserve: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_action.show(self, prefix + '  ') 
    outstr += prefix + 'matchfield: \n' 
    outstr += self.matchfield.show(prefix + '  ') 
    outstr += prefix + 'increment: '+  str(self.increment) + '\n' 
#     outstr += prefix + 'reserve: '+  str(self.reserve) + '\n' 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_action_modifyfield._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_action.unpack(raw,offset)
    offset=self.matchfield.unpack(raw, offset)
    offset,self.increment = _unpack('!L', raw, offset)
    offset=_skip(raw, offset, 4)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_action.pack(self)
    packed += self.matchfield.pack()
    packed += struct.pack("!L" ,self.increment)
    packed += _PAD4
    return packed

  
## action 4  ADD_FIELD 
@openflow_action("ADD_FIELD", 4)
class ofp_action_addfield (ofp_action):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_action._MIN_LENGTH + 8 + OFP_MAX_FIELD_LENGTH_IN_BYTE
  #_MAX_LENGTH = 0
  def set_fieldValue(self,hexstring):
#     @parm: hexstring should be a hex string like "aaaaffff"
#     if not isdigit(hexstring):
#         print ("hexstring can't change to ")
#         return 0
    if (len(hexstring)%2):
        hexstring +='0'
    if (len(hexstring)>OFP_MAX_FIELD_LENGTH_IN_BYTE*2 ):
        hexstring=hexstring[:OFP_MAX_FIELD_LENGTH_IN_BYTE*2]
    self.value=[]
    
    
    for i in xrange(0,len(hexstring)/2):
        int_c=int(hexstring[i*2:i*2+2],16)    
        #print (hexstring[i*2:i*2+2]),int_c
        self.value.append(int_c)

  def __init__(self,**kw):
    ofp_action.__init__(self)
    self.fieldId = 0
    self.fieldPosition = 0
    self.fieldLength = 0
    self.fieldValue = []
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_action.__eq__(self, other) : return False
    if self.fieldId != other.fieldId: return False
    if self.fieldPosition != other.fieldPosition: return False
    if self.fieldLength != other.fieldLength: return False
    if self.fieldValue != other.fieldValue: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_action.show(self, prefix + '  ')
    outstr += prefix + 'fieldId: '+  str(self.fieldId) + '\n' 
    outstr += prefix + 'fieldPosition: '+  str(self.fieldPosition) + '\n' 
    outstr += prefix + 'fieldLength: '+  str(self.fieldLength) + '\n' 
    outstr += prefix + 'fieldValue: '+  str(self.fieldValue) + '\n' 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_action_addfield._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_action.unpack(raw,offset)
    offset,self.fieldId = _unpack('!H', raw, offset)
    offset,self.fieldPosition = _unpack('!H', raw, offset)
    offset,self.fieldLength = _unpack('!L', raw, offset)
    offset,self.fieldValue = _unpack('!Q', raw, offset)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_action.pack(self)
    packed += struct.pack("!H" ,self.fieldId)
    packed += struct.pack("!H" ,self.fieldPosition)
    packed += struct.pack("!L" ,self.fieldLength)
#     packed += struct.pack("!Q" ,self.fieldValue)
    
    for i in self.fieldValue:
        packed += struct.pack("!B" ,i)
        
    packed +=_PAD*(OFP_MAX_FIELD_LENGTH_IN_BYTE-len(self.fieldValue))
    
    return packed

     
## action 5  DELETE_FIELD 
@openflow_action("DELETE_FIELD", 5)
class ofp_action_deletefield (ofp_action):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_action._MIN_LENGTH + 8 +ofp_match20._MIN_LENGTH
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_action.__init__(self)
    self.tagPosition = 0
    self.tagLengthValueType = 0
    self.reverse = 0   #array [5]
    self.tagLengthValue = 0
    self.tagLengthField = ofp_match20()
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_action.__eq__(self, other) : return False
    if self.tagPosition != other.tagPosition: return False
    if self.tagLengthValueType != other.tagLengthValueType: return False
    if self.reverse != other.reverse: return False
    if self.tagLengthValue != other.tagLengthValue: return False
    if self.tagLengthField != other.tagLengthField: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_action.show(self, prefix + '  ')
    outstr += prefix + 'tagPosition: '+  str(self.tagPosition) + '\n' 
    outstr += prefix + 'tagLengthValueType: '+  str(self.tagLengthValueType) + '\n' 
    outstr += prefix + 'reverse: '+  str(self.reverse) + '\n' 
    outstr += prefix + 'tagLengthValue: '+  str(self.tagLengthValue) + '\n' 
    outstr += prefix + 'tagLengthField: \n' 
    outstr += self.tagLengthField.show(prefix + '  ')
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_action_deletefield._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_action.unpack(raw,offset)
    offset,self.tagPosition = _unpack('!H', raw, offset)
    offset,self.tagLengthValueType = _unpack('!B', raw, offset)
    offset = _skip(raw, offset, 5)
    offset,self.tagLengthValue = _unpack('!L', raw, offset)
    offset=self.tagLengthField.unpack(raw, offset)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_action.pack(self)
    packed += struct.pack("!H" ,self.tagPosition)
    packed += struct.pack("!B" ,self.tagLengthValueType)
    packed += _PAD * 5
    if self.tagLengthValueType==0:
        packed += struct.pack("!L" ,self.tagLengthValue)
        packed += _PAD4
    elif self.tagLengthValueType == 1 and self.tagLengthField != ofp_match20():
        packed += self.tagLengthField.pack()
    else:
        packed += _PAD*ofp_match20._MIN_LENGTH                                       
        #packed += self.tagLengthField.pack()
    return packed

       
## action 6  CALCULATE_CHECKSUM
@openflow_action("CALCULATE_CHECKSUM", 6)
class ofp_action_calculatechecksum (ofp_action):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_action._MIN_LENGTH + 16
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_action.__init__(self)
    self.checksumPosType = 0
    self.calcPosType = 0
    self.checksumPosition = 0
    self.checksumLength = 0
    self.calcStarPosition = 0
    self.calcLength = 0
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_action.__eq__(self, other) : return False
    if self.checksumPosType != other.checksumPosType: return False
    if self.calcPosType != other.calcPosType: return False
    if self.checksumPosition != other.checksumPosition: return False
    if self.checksumLength != other.checksumLength: return False
    if self.calcStarPosition != other.calcStarPosition: return False
    if self.calcLength != other.calcLength: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_action.show(self, prefix + '  ')
    outstr += prefix + 'checksumPosType: '+  str(self.checksumPosType) + '\n' 
    outstr += prefix + 'calcPosType: '+  str(self.calcPosType) + '\n' 
    outstr += prefix + 'checksumPosition: '+  str(self.checksumPosition) + '\n' 
    outstr += prefix + 'checksumLength: '+  str(self.checksumLength) + '\n' 
    outstr += prefix + 'calcStarPosition: '+  str(self.calcStarPosition) + '\n' 
    outstr += prefix + 'calcLength: '+  str(self.calcLength) + '\n' 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_action_calculatechecksum._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_action.unpack(raw,offset)
    offset,self.checksumPosType = _unpack('!B', raw, offset)
    offset,self.calcPosType = _unpack('!B', raw, offset)
    offset,self.checksumPosition = _unpack('!H', raw, offset)
    offset,self.checksumLength = _unpack('!H', raw, offset)
    offset,self.calcStarPosition = _unpack('!H', raw, offset)
    offset,self.calcLength = _unpack('!H', raw, offset)
    offset = _skip(raw, offset, 6)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_action.pack(self)
    packed += struct.pack("!B" ,self.checksumPosType)
    packed += struct.pack("!B" ,self.calcPosType)
    packed += struct.pack("!H" ,self.checksumPosition)
    packed += struct.pack("!H" ,self.checksumLength)
    packed += struct.pack("!H" ,self.calcStarPosition)
    packed += struct.pack("!H" ,self.calcLength)
    packed += _PAD6
    return packed

## action 7  GROUP   
@openflow_action("GROUP", 7)
class ofp_action_group (ofp_action):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_action._MIN_LENGTH + 8
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_action.__init__(self)
    self.groupId = 0
    self.reserve = []
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_action.__eq__(self, other) : return False
    if self.groupId != other.groupId: return False
#     if self.reserve != other.reserve: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_action.show(self, prefix + '  ')
    outstr += prefix + 'groupId: '+  str(self.groupId) + '\n' 
    outstr += prefix + 'reserve: '+  str(self.reserve) + '\n' 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_action_group._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_action.unpack(raw,offset)
    offset,self.groupId = _unpack('!L', raw, offset)
    offset=_skip(raw, offset, 4)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_action.pack(self)
    packed += struct.pack("!L" ,self.groupId)
    packed += _PAD4
    return packed

## action 8  DROp
@openflow_action("DROP", 8)
class ofp_action_drop (ofp_action):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_action._MIN_LENGTH + 8
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_action.__init__(self)
    self.reason = 0
#     self.reserve = []
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_action.__eq__(self, other) : return False
    if self.reason != other.reason: return False
#     if self.reserve != other.reserve: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_action.show(self, prefix + '  ')
    outstr += prefix + 'reason: '+  str(self.reason) + '\n' 
#     outstr += prefix + 'reserve: '+  str(self.reserve) + '\n' 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_action_drop._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_action.unpack(raw,offset)
    offset,self.reason = _unpack('!L', raw, offset)
    offset=_skip(raw, offset, 4)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_action.pack(self)
    packed += struct.pack("!L" ,self.reason)
    packed += _PAD4
    return packed
    
## action 9  PACKET_IN    
@openflow_action("PACKET_IN", 9)
class ofp_action_packetin (ofp_action):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_action._MIN_LENGTH + 8
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_action.__init__(self)
    self.reason = 0
    self.reserve = []
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_action.__eq__(self, other) : return False
    if self.reason != other.reason: return False
    if self.reserve != other.reserve: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_action.show(self, prefix + '  ')
    outstr += prefix + 'reason: '+  str(self.reason) + '\n' 
    outstr += prefix + 'reserve: '+  str(self.reserve) + '\n' 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_action_packetin._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_action.unpack(raw,offset)
    offset,self.reason = _unpack('!L', raw, offset)
    for i in xrange(0,4):
            offset,temp_reserve = _unpack('!B', raw, offset)
            self.reserve.append(temp_reserve)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_action.pack(self)
    packed += struct.pack("!L" ,self.reason)
    packed += _PAD4
    return packed

       
## action 10  COUNTER
@openflow_action("COUNTER", 10)
class ofp_action_counter (ofp_action):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_action._MIN_LENGTH + 8
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_action.__init__(self)
    self.counterId = 0
    self.reserve = []
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_action.__eq__(self, other) : return False
    if self.counterId != other.counterId: return False
    if self.reserve != other.reserve: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_action.show(self, prefix + '  ')
    outstr += prefix + 'counterId: '+  str(self.counterId) + '\n' 
    outstr += prefix + 'reserve: '+  str(self.reserve) + '\n' 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_action_counter._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_action.unpack(raw,offset)
    offset,self.counterId = _unpack('!L', raw, offset)
    for i in xrange(0,4):
            offset,temp_reserve = _unpack('!B', raw, offset)
            self.reserve.append(temp_reserve)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_action.pack(self)
    packed += struct.pack("!L" ,self.counterId)
    packed += _PAD4
    return packed


## action 11 EXPERIMENTER                  
@openflow_action("EXPERIMENTER", 11) 
class ofp_action_experimenter (ofp_action):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_action._MIN_LENGTH + 8
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_action.__init__(self)
    self.exterimenter = 0
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_action.__eq__(self, other) : return False
    if self.exterimenter != other.exterimenter: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_action.show(self, prefix + '  ')
    outstr += prefix + 'exterimenter: '+  str(self.exterimenter) + '\n' 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_action_experimenter._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_action.unpack(raw,offset)
    offset,self.exterimenter = _unpack('!L', raw, offset)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_action.pack(self)
    packed += struct.pack("!L" ,self.exterimenter)
    return packed


"""
    @author: milktank
    @todo: define the POF instruction struct
    @version: 1.0
    @time: 2014-10-10 15:14:33
    @list: 
    ## instruction 1  GOTO_TABLE 
    ## instruction 2  WRITE_METADATA
    ## instruction 4  APPLY_ACTIONS       
    ## instruction 6  METER  
    ## instruction 7  WRITE_METADATA_FROM_PACKET      
    ## instruction 8  GOTO_DIRECT_TABLE        
    ## instruction 9  CONDITIONAL_JMP  
    ## instruction 10  CALCULATE_FIELD   
    ## instruction 11  MOVE_PACKET_OFFSET     
"""

##POF  20.2.3 GOTO_TABLE Instruction 1 Go-table by milktank
@openflow_instruction("GOTO_TABLE", 1)
class ofp_instruction_gototable (ofp_instruction):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo: ofp_instruction_gototable struct

  """
  _MIN_LENGTH = ofp_instruction._MIN_LENGTH+8
  _MAX_LENGTH = ofp_instruction._MIN_LENGTH+8+ofp_match20._MIN_LENGTH * OFP_MAX_MATCH_FIELD_NUM

  def __init__(self,**kw):
    ofp_instruction.__init__(self)
    self.nextTableId = 0
    self.matchFieldNum = 0
    self.packetOffset = 0
    self.padding = 0
    self.matchList = []
    initHelper(self, kw)



  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_instruction.__eq__(self, other) : return False
    if self.nextTableId != other.nextTableId: return False
    if self.matchFieldNum != other.matchFieldNum: return False
    if self.packetOffset != other.packetOffset: return False
    if self.padding != other.padding: return False
    if self.matchList != other.matchList: return False
    return True


  def show(self,prefix=''):
    outstr =''
    outstr += ofp_instruction.show(self, prefix + '  ')
    outstr += prefix + 'nextTableId: '+  str(self.nextTableId) + '\n' 
    outstr += prefix + 'matchFieldNum: '+  str(self.matchFieldNum) + '\n' 
    outstr += prefix + 'packetOffset: '+  str(self.packetOffset) + '\n' 
    outstr += prefix + 'padding: '+  str(self.padding) + '\n' 
    outstr += prefix + 'matchList: '+  str(self.matchList) + '\n' 
    return outstr



  def __repr__(self):
    return self.show()



  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()



  def __len__(self):
    return ofp_instruction._MIN_LENGTH+8+ofp_match20._MIN_LENGTH * OFP_MAX_MATCH_FIELD_NUM    ##Need to change to the correct length of the packet 



  def unpack(self,raw,offset=0):
    _offset = offset
    offset=ofp_instruction.unpack(raw, offset)
    offset,self.nextTableId = _unpack('!B', raw, offset)
    offset,self.matchFieldNum = _unpack('!B', raw, offset)
    offset,self.packetOffset = _unpack('!H', raw, offset)
    offset,self.padding = _unpack('!L', raw, offset)
    for i in xrange(0,8):
        temp_matchList=ofp_match20()
        offset = temp_matchList.unpack(raw,offset)
        self.matchList.append(temp_matchList)
    assert offset - _offset == len(self)
    return offset



  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_instruction.pack(self)
    packed += struct.pack("!B" ,self.nextTableId)
    packed += struct.pack("!B" ,len(self.matchList))
    packed += struct.pack("!H" ,self.packetOffset)
    packed += struct.pack("!L" ,self.padding)
    numcount=0
    for i in self.matchList:
        packed+= i.pack()
        numcount += 1
    if numcount<OFP_MAX_MATCH_FIELD_NUM:
        packed +=_PAD*(OFP_MAX_MATCH_FIELD_NUM - numcount) * ofp_match20._MIN_LENGTH 
    return packed


##POF  20.2.4 WRITE_METADATA Instruction 2 WRITE_METADATA by milktank
@openflow_instruction("WRITE_METADATA", 2)
class ofp_instruction_writemetadata (ofp_instruction):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """


  _MIN_LENGTH = ofp_instruction._MIN_LENGTH + OFP_MAX_FIELD_LENGTH_IN_BYTE + 8
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_instruction.__init__(self)
    self.metaDataOffset = 0
    self.writeLength = 0
    self.value = []
    self.reverse = 0
    initHelper(self, kw)



  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_instruction.__eq__(self, other) : return False
    if self.metaDataOffset != other.metaDataOffset: return False
    if self.writeLength != other.writeLength: return False
    if self.value != other.value: return False
    if self.reverse != other.reverse: return False
    return True


  def show(self,prefix=''):
    outstr =''
    outstr += ofp_instruction.show(self, prefix + '  ')
    outstr += prefix + 'metaDataOffset: '+  str(self.metaDataOffset) + '\n' 
    outstr += prefix + 'writeLength: '+  str(self.writeLength) + '\n' 
    outstr += prefix + 'value: '+  str(self.value) + '\n'
    outstr += prefix + 'reverse: '+  str(self.reverse) + '\n'  
    return outstr



  def __repr__(self):
    return self.show()



  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()



  def __len__(self):
    return ofp_instruction_writemetadata._MIN_LENGTH    ##Need to change to the correct length of the packet 



  def unpack(self,raw,offset=0):
    _offset = offset
    offset=ofp_instruction.unpack(raw, offset)
    offset,self.metaDataOffset = _unpack('!H', raw, offset)
    offset,self.writeLength = _unpack('!H', raw, offset)
    offset,self.value = _unpack('!16s', raw, offset)
    offset= _skip(raw, offset, 4)
    assert offset - _offset == len(self)
    return offset



  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_instruction.pack(self)
    packed += struct.pack("!H" ,self.metaDataOffset)
    packed += struct.pack("!H" ,self.writeLength)
    if (len(self.value) == 0):
        packed += _PAD * OFP_MAX_FIELD_LENGTH_IN_BYTE
    else:
        value_length = len(self.value)
        if value_length > OFP_MAX_FIELD_LENGTH_IN_BYTE:
            pass
        else:
            for i in self.value:
                packed += struct.pack("!B" ,i)
            packed += _PAD*( OFP_MAX_FIELD_LENGTH_IN_BYTE - len(self.value) )
    packed += _PAD * 4
    return packed


##POF  20.2.5 apply_action Instruction 3 apply_action by milktank
@openflow_instruction("APPLY_ACTIONS", 4)
class ofp_instruction_applyaction (ofp_instruction):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_instruction._MIN_LENGTH + 8
  _MAX_LENGTH = ofp_instruction._MIN_LENGTH + 8 +OFP_MAX_ACTION_NUMBER_PER_INSTRUCTION * ofp_action._MAX_LENGTH

  def __init__(self,**kw):
    ofp_instruction.__init__(self)
    self.actionNum = 0
    self.reserve = []
    self.actionList = []
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_instruction.__eq__(self, other) : return False
    if self.actionNum != other.actionNum: return False
    if self.reserve != other.reserve: return False
    if self.actionList != other.actionList: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_instruction.show(self, prefix + '  ')
    outstr += prefix + 'actionNum: '+  str(len(self.actionList)) + '\n' 
    outstr += prefix + 'reserve: '+  str(self.reserve) + '\n' 
    outstr += prefix + 'actionList: '+  str(self.actionList) + '\n' 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_instruction_applyaction._MAX_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_instruction.unpack(raw,offset)
    offset,self.actionNum = _unpack('!B', raw, offset)
    for i in xrange(0,7):
            offset,temp_reserve = _unpack('!B', raw, offset)
            self.reserve.append(temp_reserve)
    for i in xrange(0,OFP_MAX_ACTION_NUMBER_PER_INSTRUCTION):
        temp_actionList=ofp_action()
        offset = temp_actionList.unpack(raw,offset)
        self.actionList.append(temp_actionList)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_instruction.pack(self)
    packed += struct.pack("!B" ,len(self.actionList))
    packed += _PAD*7
    numcount=0  
    for i in self.actionList:
        packed += i.pack()
        if ofp_action._MAX_LENGTH > len(i):
            packed += _PAD*(ofp_action._MAX_LENGTH -len(i))
        numcount += 1
    if numcount < OFP_MAX_ACTION_NUMBER_PER_INSTRUCTION:
        packed += _PAD*(OFP_MAX_ACTION_NUMBER_PER_INSTRUCTION - numcount )*ofp_action._MAX_LENGTH
    return packed

##POF  20.2.6 ofp_instruction_meter Instruction 2 ofp_instruction_meter by milktank
@openflow_instruction("METER", 6)
class ofp_instruction_meter (ofp_instruction):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_instruction._MIN_LENGTH + 8
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_instruction.__init__(self)
    self.meterId = 0
    self.reserve = []
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_instruction.__eq__(self, other) : return False
    if self.meterId != other.meterId: return False
    if self.reserve != other.reserve: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_instruction.show(self, prefix + '  ')
    outstr += prefix + 'meterId: '+  str(self.meterId) + '\n' 
    outstr += prefix + 'reserve: '+  str(self.reserve) + '\n' 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_instruction_meter._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_instruction.unpack(raw,offset)
    offset,self.meterId = _unpack('!L', raw, offset)
    for i in xrange(0,4):
            offset,temp_reserve = _unpack('!B', raw, offset)
            self.reserve.append(temp_reserve)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_instruction.pack(self)
    packed += struct.pack("!L" ,self.meterId)
    packed +=_PAD4
    return packed

##POF  20.2.7 ofp_instruction_writemetadatafrompacket Instruction 7  by milktank
@openflow_instruction("WRITE_METADATA_FROM_PACKET", 7)
class ofp_instruction_writemetadatafrompacket (ofp_instruction):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_instruction._MIN_LENGTH + 8
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_instruction.__init__(self)
    self.metadataOffset = 0
    self.packetOffset = 0
    self.writeLength = 0
    self.reserve = []
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_instruction.__eq__(self, other) : return False
    if self.metadataOffset != other.metadataOffset: return False
    if self.packetOffset != other.packetOffset: return False
    if self.writeLength != other.writeLength: return False
    if self.reserve != other.reserve: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_instruction.show(self, prefix + '  ')
    outstr += prefix + 'metadataOffset: '+  str(self.metadataOffset) + '\n' 
    outstr += prefix + 'packetOffset: '+  str(self.packetOffset) + '\n' 
    outstr += prefix + 'writeLength: '+  str(self.writeLength) + '\n' 
    outstr += prefix + 'reserve: '+  str(self.reserve) + '\n' 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_instruction_writemetadatafrompacket._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_instruction.unpack(raw,offset)
    offset,self.metadataOffset = _unpack('!H', raw, offset)
    offset,self.packetOffset = _unpack('!H', raw, offset)
    offset,self.writeLength = _unpack('!H', raw, offset)
    for i in xrange(0,2):
            offset,temp_reserve = _unpack('!B', raw, offset)
            self.reserve.append(temp_reserve)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_instruction.pack(self)
    packed += struct.pack("!H" ,self.metadataOffset)
    packed += struct.pack("!H" ,self.packetOffset)
    packed += struct.pack("!H" ,self.writeLength)
    packed += _PAD2
    return packed


##POF  20.2.8 WRITE_METADATA Instruction 8 WRITE_METADATA by milktank
@openflow_instruction("GOTO_DIRECT_TABLE", 8)
class ofp_instruction_gotodirecttable (ofp_instruction):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_instruction._MIN_LENGTH +8 +ofp_match20._MIN_LENGTH
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_instruction.__init__(self)
    self.nextTableId = 0
    self.indexType = 0
    self.packetOffset = 0
    self.indexValue = 0
    self.indexField = ofp_match20()
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_instruction.__eq__(self, other) : return False
    if self.nextTableId != other.nextTableId: return False
    if self.indexType != other.indexType: return False
    if self.packetOffset != other.packetOffset: return False
    if self.indexValue != other.indexValue: return False
    if self.indexField != other.indexField: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_instruction.show(self, prefix + '  ')
    outstr += prefix + 'nextTableId: '+  str(self.nextTableId) + '\n' 
    outstr += prefix + 'indexType: '+  str(self.indexType) + '\n' 
    outstr += prefix + 'packetOffset: '+  str(self.packetOffset) + '\n' 
    outstr += prefix + 'indexValue: '+  str(self.indexValue) + '\n' 
    outstr += prefix + 'indexField: \n' 
    outstr += self.indexField.show(prefix + '  ') 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_instruction_gotodirecttable._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_instruction.unpack(raw,offset)
    offset,self.nextTableId = _unpack('!B', raw, offset)
    offset,self.indexType = _unpack('!B', raw, offset)
    offset,self.packetOffset = _unpack('!H', raw, offset)
    offset = _skip(raw, offset, 4)
    if self.indexType == 0:
        offset,self.indexValue = _unpack('!L', raw, offset)
        offset = _skip(raw, offset, 4)
        self.indexField = None
    elif self.indexType == 1:
        offset=self.indexField.unpack(raw, offset)
    else:
        self.indexType = 0
        self.indexField = None
        offset = _skip(raw, offset, ofp_match20._MIN_LENGTH)
    offset=self.indexField.unpack(raw, offset)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_instruction.pack(self)
    packed += struct.pack("!B" ,self.nextTableId)
    packed += struct.pack("!B" ,self.indexType)
    packed += struct.pack("!H" ,self.packetOffset)
    packed += _PAD4
    if self.indexType== 0 :
        packed += struct.pack( "!L" ,self.indexValue)
        packed += _PAD4
    elif self.indexType == 1 and self.indexField!= init_match20:
        packed += self.indexField.pack()
    else:
        packed += _PAD* ofp_match20._MIN_LENGTH 

    #packed += self.indexField.pack()
    return packed

@openflow_instruction("CONDITIONAL_JMP", 9)
class ofp_instruction_conditionaljmp (ofp_instruction):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_instruction._MIN_LENGTH + 8 + 5 * ofp_match20._MIN_LENGTH  
  #_MAX_LENGTH = 0

  def __init__(self,**kw):
    ofp_instruction.__init__(self)
    self.field2_valueType = 0
    self.offset1_direction = 0
    self.offset1_valueType = 0
    self.offset2_direction = 0
    self.offset2_valueType = 0
    self.offset3_direction = 0
    self.offset3_valueType = 0
    
    self.field1 = ofp_match20()
    self.field2_value = 0
    self.field2 = ofp_match20()
    self.offset1_value = 0
    self.offset1_field = ofp_match20()
    self.offset2_value = 0
    self.offset2_field = ofp_match20()
    self.offset3_value = 0
    self.offset3_field = ofp_match20()
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_instruction.__eq__(self, other) : return False
    if self.field2_valueType != other.field2_valueType: return False
    if self.offset1_direction != other.offset1_direction: return False
    if self.offset1_valueType != other.offset1_valueType: return False
    if self.offset2_direction != other.offset2_direction: return False
    if self.offset2_valueType != other.offset2_valueType: return False
    if self.offset3_direction != other.offset3_direction: return False
    if self.offset3_valueType != other.offset3_valueType: return False
    
    if self.field1 != other.field1: return False
    if self.field2_value != other.field2_value: return False
    if self.field2 != other.field2: return False
    if self.offset1_value != other.offset1_value: return False
    if self.offset1_field != other.offset1_field: return False
    if self.offset2_value != other.offset2_value: return False
    if self.offset2_field != other.offset2_field: return False
    if self.offset3_value != other.offset3_value: return False
    if self.offset3_field != other.offset3_field: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_instruction.show(self, prefix + '  ')
    outstr += prefix + 'field2_valueType: '+  str(self.field2_valueType) + '\n' 
    outstr += prefix + 'offset1_direction: '+  str(self.offset1_direction) + '\n' 
    outstr += prefix + 'offset1_valueType: '+  str(self.offset1_valueType) + '\n' 
    outstr += prefix + 'offset2_direction: '+  str(self.offset2_direction) + '\n' 
    outstr += prefix + 'offset2_valueType: '+  str(self.offset2_valueType) + '\n' 
    outstr += prefix + 'offset3_direction: '+  str(self.offset3_direction) + '\n' 
    outstr += prefix + 'offset3_valueType: '+  str(self.offset3_valueType) + '\n' 
    outstr += prefix + 'field1: \n' 
    outstr += self.field1.show(prefix + '  ')
    outstr += prefix + 'field2_value: '+  str(self.field2_value) + '\n'  
    outstr += prefix + 'field2: \n' 
    outstr += self.field2.show(prefix + '  ')
    outstr += prefix + 'offset1_value: '+  str(self.offset1_value) + '\n' 
    outstr += prefix + 'offset1_field: \n' 
    outstr += self.offset1_field.show(prefix + '  ') 
    outstr += prefix + 'offset2_value: '+  str(self.offset2_value) + '\n' 
    outstr += prefix + 'offset2_field: \n' 
    outstr += self.offset2_field.show(prefix + '  ') 
    outstr += prefix + 'offset3_value: '+  str(self.offset3_value) + '\n'  
    outstr += prefix + 'offset3_field: \n' 
    outstr += self.offset3_field.show(prefix + '  ')
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_instruction_conditionaljmp._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_instruction.unpack(raw,offset)
    offset,self.field2_valueType = _unpack('!B', raw, offset)
    offset,self.offset1_direction = _unpack('!B', raw, offset)
    offset,self.offset1_valueType = _unpack('!B', raw, offset)
    offset,self.offset2_direction = _unpack('!B', raw, offset)
    offset,self.offset2_valueType = _unpack('!B', raw, offset)
    offset,self.offset3_direction = _unpack('!B', raw, offset)
    offset,self.offset3_valueType = _unpack('!B', raw, offset)
    offset= _skip(raw, offset, 1)
    offset=self.field1.unpack(raw, offset)
    offset,self.field2_value = _unpack('!L', raw, offset)
    offset=self.field2.unpack(raw, offset)
    offset,self.offset1_value = _unpack('!L', raw, offset)
    offset=self.offset1_field.unpack(raw, offset)
    offset,self.offset2_value = _unpack('!L', raw, offset)
    offset=self.offset2_field.unpack(raw, offset)
    offset,self.offset3_value = _unpack('!L', raw, offset)
    offset=self.offset3_field.unpack(raw, offset)
    assert offset - _offset == len(self)
    return offset

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_instruction.pack(self)
    packed += struct.pack("!B" ,self.field2_valueType)
    packed += struct.pack("!B" ,self.offset1_direction)
    packed += struct.pack("!B" ,self.offset1_valueType)
    packed += struct.pack("!B" ,self.offset2_direction)
    packed += struct.pack("!B" ,self.offset2_valueType)
    packed += struct.pack("!B" ,self.offset3_direction)
    packed += struct.pack("!B" ,self.offset3_valueType)
    packed += _PAD
    if self.field1 != init_match20:        
        packed += self.field1.pack()
    else:
        packed += _PAD*ofp_match20._MIN_LENGTH    
        
    if self.field2_valueType== 0 :
        packed += struct.pack( "!L" ,self.field2_value)
        packed += _PAD4
    elif self.field2_valueType== 1 and self.field2!= init_match20:
        packed += self.field2.pack ()
    else:
        packed += _PAD* ofp_match20._MIN_LENGTH 

    if self.offset1_valueType== 0 :
        packed += struct.pack( "!L" ,self.offset1_value)
        packed += _PAD4
    elif self.offset1_valueType== 1 and self.offset1_field!= init_match20:
        packed += self.offset1_field.pack ()
    else:
        packed += _PAD* ofp_match20._MIN_LENGTH 


    if self.offset2_valueType== 0 :
        packed += struct.pack( "!L" ,self.offset2_value)
        packed += _PAD4
    elif self.offset2_valueType== 1 and self.offset2_field!= init_match20:
        packed += self.offset2_field.pack ()
    else:
        packed += _PAD* ofp_match20._MIN_LENGTH 
    
    if self.offset3_valueType == 0 :
        packed += struct.pack( "!L" ,self.offset3_value)
        packed += _PAD4
    elif self.offset3_valueType== 1 and self.offset3_field != init_match20:
        packed += self.offset3_field.pack ()
    else:
        packed += _PAD* ofp_match20._MIN_LENGTH 
    
    
    return packed


##POF  20.2.10 CALCULATE_FIELD


@openflow_instruction("CALCULATE_FIELD", 10)
class ofp_instruction_calculatefiled (ofp_instruction):  #add by Tan
  _MIN_LENGTH = ofp_instruction._MIN_LENGTH + 8 + ofp_match20._MIN_LENGTH + ofp_match20._MIN_LENGTH
  def __init__(self,**kw):
    ofp_instruction.__init__(self)
    self.calcType = 0
    self.src_valueType = 0    #0: use srcField_Value; 1: use srcField;
    self.padding = 0   #array [5]
    self.des_field = ofp_match20()
    self.src_value = 0
    self.src_field = ofp_match20()

    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_instruction.__eq__(self, other) : return False
    if self.calcType != other.calcType: return False
    if self.src_valueType != other.src_valueType: return False
    if self.padding != other.padding: return False
    if self.des_field != other.des_field: return False
    if self.src_value != other.src_value: return False
    if self.src_field != other.src_field: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_instruction.show(self, prefix + '  ')
    outstr += prefix + 'calcType: '+  str(self.calcType) + '\n' 
    outstr += prefix + 'src_valueType: '+  str(self.src_valueType) + '\n' 
    outstr += prefix + 'padding: '+  str(self.padding) + '\n' 
    outstr += prefix + 'des_field: \n' 
    outstr += self.des_field.show(prefix + '  ')
    outstr += prefix + 'src_value: '+  str(self.src_value) + '\n' 
    outstr += prefix + 'src_field: \n' 
    outstr += self.src_field.show(prefix + '  ')
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_instruction_calculatefiled._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_instruction.unpack(raw,offset)
    
    offset,ct = _unpack('!H', raw, offset)
    
    if ct >= 0 and ct < ofp_calc_type_rev_map.len():
        self.calcType = ct
    else:
        self.calcType = None
        
    offset,self.src_valueType = _unpack('!B', raw, offset)    
    offset = _skip(raw, offset, 5)
    offset=self.des_field.unpack(raw, offset)
    
    if self.src_valueType == 0:
        offset,self.src_value = _unpack('!L', raw, offset)
        offset = _skip(raw, offset, 4)
        self.src_field = None
    elif self.src_valueType == 1:
        self.src_value = 0
        offset=self.src_field.unpack(raw, offset)
    else:
        self.src_value = 0
        self.src_field = None
        offset = _skip(raw, offset, ofp_match20._MIN_LENGTH)
        
    assert offset - _offset == len(self)
    return offset


  def pack(self):
    packed=b""
    packed += ofp_instruction.pack(self)
    packed += struct.pack("!BH" ,self.calcType, self.src_valueType)
    packed += _PAD * 5
    if self.des_field != init_match20:
        packed += self.des_field.pack()
    else:
        packed += _PAD * ofp_match20._MIN_LENGTH
    
    if self.src_valueType == 0:
        packed += struct.pack("!L" ,self.src_value)
        packed +=  _PAD * 4
    elif self.src_field != init_match20:
        packed += self.src_field.pack()
    else:
        packed += _PAD * ofp_match20._MIN_LENGTH
    return packed


##POF  20.2.11 MOVE_PACKET_OFFSET
@openflow_instruction("MOVE_PACKET_OFFSET", 11)
class ofp_instruction_movepacketoffset (ofp_instruction):  #add by Tan
  _MIN_LENGTH = ofp_instruction._MIN_LENGTH + 8 + ofp_match20._MIN_LENGTH
  def __init__(self,**kw):
    ofp_instruction.__init__(self)
    self.direction = 0    #0: forward; 1: backward
    self.valueType = 0
    self.padding = 0   #array [6]
    self.move_value = 0
    self.move_field = ofp_match20()

    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_instruction.__eq__(self, other) : return False
    if self.direction != other.direction: return False
    if self.valueType != other.src_valueType: return False
    if self.padding != other.padding: return False
    if self.move_value != other.move_value: return False
    if self.move_field != other.move_field: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_instruction.show(self, prefix + '  ')
    outstr += prefix + 'direction: '+  str(self.direction) + '\n' 
    outstr += prefix + 'valueType: '+  str(self.valueType) + '\n' 
    outstr += prefix + 'padding: '+  str(self.padding) + '\n' 
    outstr += prefix + 'move_value: '+  str(self.move_value) + '\n' 
    outstr += prefix + 'move_field: \n' 
    outstr += self.move_field.show(prefix + '  ')
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_instruction_movepacketoffset._MIN_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset = ofp_instruction.unpack(raw,offset)
    offset,(self.direction, self.valueType) = _unpack('!BB', raw, offset)
    offset = _skip(raw, offset, 6)
    #offset, self.move_value = _unpack('!L', raw, offset)
    
    if self.valueType == 0:
        offset,self.move_value = _unpack('!L', raw, offset)
        offset = _skip(raw, offset, 4)
        self.move_field = None
    elif self.valueType == 1:
        self.move_value = 0
        offset=self.move_field.unpack(raw, offset)
    else:
        self.move_value = 0
        self.move_field = None
        offset = _skip(raw, offset, ofp_match20._MIN_LENGTH)
        
    assert offset - _offset == len(self)
    return offset


  def pack(self):
    packed=b""
    packed += ofp_instruction.pack(self)
    packed += struct.pack("!BB" ,self.direction, self.valueType)
    packed += _PAD * 6

    if self.valueType == 0:
        packed += struct.pack("!L" ,self.move_value)
        packed +=  _PAD * 4
    elif self.valueType == 1 and self.move_field != init_match20:
        packed += self.move_field.pack()
    else:
        packed += _PAD * ofp_match20._MIN_LENGTH
    return packed

#To avoid collision by Tan
'''
class ofp_action_generic (ofp_action_base):
  _MIN_LENGTH = 8
  def __init__ (self, **kw):
    self.type = None # Purposely bad
    self.data = _PAD4

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!HH", self.type, len(self))
    packed += self.data
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.type, length) = _unpack("!HH", raw, offset)
    offset,self.data = _read(raw, offset, length-4)
    assert offset - _offset == len(self)
    return offset

  def __len__ (self):
    return 4 + len(self.data)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if self.data != other.data: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    return outstr


@openflow_action('OFPAT_OUTPUT', 0)
class ofp_action_output_2 (ofp_action_base): #change to avoid collision
  def __init__ (self, **kw):
    self.port = None # Purposely bad -- require specification
    self.max_len = 0xffFF

    initHelper(self, kw)

  def pack (self):
    if self.port != OFPP_CONTROLLER:
      self.max_len = 0

    assert self._assert()

    packed = b""
    packed += struct.pack("!HHHH", self.type, len(self), self.port,
                          self.max_len)
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.type, length, self.port, self.max_len) = \
        _unpack("!HHHH", raw, offset)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.port != other.port: return False
    if self.max_len != other.max_len: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'port: ' + str(self.port) + '\n'
    outstr += prefix + 'max_len: ' + str(self.max_len) + '\n'
    return outstr


@openflow_action('OFPAT_ENQUEUE', 11)
class ofp_action_enqueue (ofp_action_base):
  def __init__ (self, **kw):
    self.port = None # Require user to set
    self.queue_id = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!HHH", self.type, len(self), self.port)
    packed += _PAD6 # Pad
    packed += struct.pack("!L", self.queue_id)
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.type, length, self.port) = _unpack("!HHH", raw, offset)
    offset = _skip(raw, offset, 6)
    offset,(self.queue_id,) = _unpack("!L", raw, offset)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 16

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.port != other.port: return False
    if self.queue_id != other.queue_id: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'port: ' + str(self.port) + '\n'
    outstr += prefix + 'queue_id: ' + str(self.queue_id) + '\n'
    return outstr


@openflow_action('OFPAT_STRIP_VLAN', 3)
class ofp_action_strip_vlan (ofp_action_base):
  def __init__ (self):
    pass

  def pack (self):
    packed = struct.pack("!HHi", self.type, len(self), 0)
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.type, length) = _unpack("!HH", raw, offset)
    offset = _skip(raw, offset, 4)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    return outstr


@openflow_action('OFPAT_SET_VLAN_VID', 1)
class ofp_action_vlan_vid (ofp_action_base):
  def __init__ (self, **kw):
    self.vlan_vid = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!HHH", self.type, len(self), self.vlan_vid)
    packed += _PAD2 # Pad
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.type, length, self.vlan_vid) = \
        _unpack("!HHH", raw, offset)
    offset = _skip(raw, offset, 2)
    #TODO: check length for this and other actions
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.vlan_vid != other.vlan_vid: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'vlan_vid: ' + str(self.vlan_vid) + '\n'
    return outstr


@openflow_action('OFPAT_SET_VLAN_PCP', 2)
class ofp_action_vlan_pcp (ofp_action_base):
  def __init__ (self, **kw):
    self.vlan_pcp = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!HHB", self.type, len(self), self.vlan_pcp)
    packed += _PAD3 # Pad
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.type, length, self.vlan_pcp) = \
        _unpack("!HHB", raw, offset)
    offset = _skip(raw, offset, 3)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.vlan_pcp != other.vlan_pcp: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'vlan_pcp: ' + str(self.vlan_pcp) + '\n'
    return outstr


@openflow_action('OFPAT_SET_DL_DST', 5)
@openflow_action('OFPAT_SET_DL_SRC', 4)
class ofp_action_dl_addr (ofp_action_base):
  @classmethod
  def set_dst (cls, dl_addr = None):
    return cls(OFPAT_SET_DL_DST, dl_addr)
  @classmethod
  def set_src (cls, dl_addr = None):
    return cls(OFPAT_SET_DL_SRC, dl_addr)

  def __init__ (self, type = None, dl_addr = None):
    """
    'type' should be OFPAT_SET_DL_SRC or OFPAT_SET_DL_DST.
    """
    self.type = type
    self.dl_addr = EMPTY_ETH

    if dl_addr is not None:
      self.dl_addr = EthAddr(dl_addr)

  def _validate (self):
    if (not isinstance(self.dl_addr, EthAddr)
        and not isinstance(self.dl_addr, bytes)):
      return "dl_addr is not string or EthAddr"
    if isinstance(self.dl_addr, bytes) and len(self.dl_addr) != 6:
      return "dl_addr is not of size 6"
    return None

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!HH", self.type, len(self))
    if isinstance(self.dl_addr, EthAddr):
      packed += self.dl_addr.toRaw()
    else:
      packed += self.dl_addr
    packed += _PAD6
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.type, length) = _unpack("!HH", raw, offset)
    offset,self.dl_addr = _readether(raw, offset)
    offset = _skip(raw, offset, 6)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 16

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.dl_addr != other.dl_addr: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'dl_addr: ' + str(self.dl_addr) + '\n'
    return outstr


@openflow_action('OFPAT_SET_NW_DST', 7)
@openflow_action('OFPAT_SET_NW_SRC', 6)
class ofp_action_nw_addr (ofp_action_base):
  @classmethod
  def set_dst (cls, nw_addr = None):
    return cls(OFPAT_SET_NW_DST, nw_addr)
  @classmethod
  def set_src (cls, nw_addr = None):
    return cls(OFPAT_SET_NW_SRC, nw_addr)

  def __init__ (self, type = None, nw_addr = None):
    """
    'type' should be OFPAT_SET_NW_SRC or OFPAT_SET_NW_DST
    """
    self.type = type

    if nw_addr is not None:
      self.nw_addr = IPAddr(nw_addr)
    else:
      self.nw_addr = IPAddr(0)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!HHl", self.type, len(self),
                          self.nw_addr.toSigned())
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.type, length) = _unpack("!HH", raw, offset)
    offset,self.nw_addr = _readip(raw, offset)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.nw_addr != other.nw_addr: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'nw_addr: ' + str(self.nw_addr) + '\n'
    return outstr


@openflow_action('OFPAT_SET_NW_TOS', 8)
class ofp_action_nw_tos (ofp_action_base):
  def __init__ (self, nw_tos = 0):
    self.nw_tos = nw_tos

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!HHB", self.type, len(self), self.nw_tos)
    packed += _PAD3
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.type, length, self.nw_tos) = _unpack("!HHB", raw, offset)
    offset = _skip(raw, offset, 3)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.nw_tos != other.nw_tos: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'nw_tos: ' + str(self.nw_tos) + '\n'
    return outstr


@openflow_action('OFPAT_SET_TP_DST', 10)
@openflow_action('OFPAT_SET_TP_SRC', 9)
class ofp_action_tp_port (ofp_action_base):
  @classmethod
  def set_dst (cls, tp_port = None):
    return cls(OFPAT_SET_TP_DST, tp_port)
  @classmethod
  def set_src (cls, tp_port = None):
    return cls(OFPAT_SET_TP_SRC, tp_port)

  def __init__ (self, type=None, tp_port = 0):
    """
    'type' is OFPAT_SET_TP_SRC/DST
    """
    self.type = type
    self.tp_port = tp_port

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!HHH", self.type, len(self), self.tp_port)
    packed += _PAD2
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.type, length, self.tp_port) = \
        _unpack("!HHH", raw, offset)
    offset = _skip(raw, offset, 2)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.tp_port != other.tp_port: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'tp_port: ' + str(self.tp_port) + '\n'
    return outstr


class ofp_action_vendor_base (ofp_action_base):
  """
  Base class for vendor actions
  """
  type = 65535 # OFPAT_VENDOR

  def _eq (self, other):
    """
    Return True if equal

    Overide this.
    """
    return True

  def _init (self, kw):
    """
    Initialize fields

    Overide this.
    """
    pass

  def _pack_body (self):
    """
    Pack body.
    """
    return b""

  def _unpack_body (self, raw, offset, avail):
    """
    Unpack body in raw starting at offset.

    Return new offset
    """
    return offset

  def _body_length (self):
    """
    Return length of body.

    Optionally override this.
    """
    return len(self._pack_body())

  def _show (self, prefix):
    """
    Format additional fields as text
    """
    return ""

  def __init__ (self, **kw):
    self._init(kw)
    assert hasattr(self, 'vendor')
    #self.vendor = 0
    initHelper(self, kw)

  def _pack_body (self):
    if hasattr(self.body, 'pack'):
      return self.body.pack()
    else:
      return bytes(self.body)

  def pack (self):
    assert self._assert()

    body = self._pack_body()

    packed = b""
    packed += struct.pack("!HHL", self.type, 8 + len(body), self.vendor)
    packed += body
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.type, length, self.vendor) = _unpack("!HHL", raw, offset)
    offset = self._unpack_body(raw, offset, length - 8)
    assert offset - _offset == len(self)
    return offset

  def __len__ (self):
    return 8 + self._body_length()

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.vendor != other.vendor: return False
    return self._eq(other)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'vendor: ' + str(self.vendor) + '\n'
    outstr += self._show(prefix)
    return outstr


@openflow_action('OFPAT_VENDOR', 65535)
class ofp_action_vendor_generic (ofp_action_base):
  def __init__ (self, **kw):
    self.vendor = 0
    self.body = b""

    initHelper(self, kw)

  def _pack_body (self):
    if hasattr(self.body, 'pack'):
      return self.body.pack()
    else:
      return bytes(self.body)

  def pack (self):
    assert self._assert()

    body = self._pack_body()

    packed = b""
    packed += struct.pack("!HHL", self.type, 8 + len(body), self.vendor)
    packed += body
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,(self.type, length, self.vendor) = _unpack("!HHL", raw, offset)
    offset,self.body = _read(raw, offset, length - 8)
    assert offset - _offset == len(self)
    return offset

  def __len__ (self):
    return 8 + len(self._pack_body())

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.type != other.type: return False
    if len(self) != len(other): return False
    if self.vendor != other.vendor: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'len: ' + str(len(self)) + '\n'
    outstr += prefix + 'vendor: ' + str(self.vendor) + '\n'
    return outstr
'''



#3. Controller-to-Switch Messages

##3.1 Handshake
@openflow_s_message("OFPT_FEATURES_REPLY", 6,
    reply_to="ofp_features_request")
class ofp_features_reply (ofp_header):  #modify by milktank
  _MIN_LENGTH = 32
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.deviceId = 0
    self.portNum = 0
    self.tableNum = 0
    self.capabilities = 0
    self.pad = 0
    self.experimenterName=None
    self.deviceForwardEngineName=None
    self.deviceLookupEngineName=None
    
    initHelper(self, kw)
  
  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("LHHL", self.deviceId, self.portNum,
                          self.tableNum,self.capabilities)
    packed += _PAD4
    packed += struct.pack("!64s64s64s", self.experimenterName, self.deviceForwardEngineName, self.deviceLookupEngineName)
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.deviceId,self.portNum,self.tableNum,self.capabilities,self.pad,self.experimenterName,self.deviceForwardEngineName,self.deviceLookupEngineName) = \
        _unpack("!LHHLL64s64s64s", raw, offset)
    assert length == len(self)
    return offset,length

  def __len__ (self):
    return 216
    #return 32 + len(self.ports) * len(ofp_phy_port)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.deviceId != other.deviceId: return False
    if self.portNum != other.portNum: return False
    if self.tableNum != other.tableNum: return False
    if self.capabilities != other.capabilities: return False
    if self.experimenterName != other.experimenterName: return False
    if self.deviceForwardEngineName != other.deviceForwardEngineName: return False
    if self.deviceLookupEngineName != other.deviceLookupEngineName: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'deviceId: ' + str(self.deviceId) + '\n'
    outstr += prefix + 'portNum: ' + str(self.portNum) + '\n'
    outstr += prefix + 'tableNum: ' + str(self.tableNum) + '\n'
    outstr += prefix + 'capabilities: ' + str(self.capabilities) + '\n'
    outstr += prefix + 'experimenterName: ' + str(self.experimenterName) + '\n'
    outstr += prefix + 'deviceForwardEngineName: ' + str(self.deviceForwardEngineName) + '\n'
    outstr += prefix + 'deviceLookupEngineName: ' + str(self.deviceLookupEngineName) + '\n'
    return outstr

  def SHOW (self):      #add by Tan, to show in the debug
    outstr = self.show()
    print (outstr)

ofp_switch_features = ofp_features_reply

#delete by Tan
"""
@openflow_s_message("OFPT_FEATURES_REPLY", 6,
    reply_to="ofp_features_request")
class ofp_features_reply (ofp_header):
  _MIN_LENGTH = 32
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.datapath_id = 0
    self.n_buffers = 0
    self.n_tables = 0
    self.capabilities = 0
    self.actions = 0
    self.ports = []
    
    initHelper(self, kw)
  
  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!QLB", self.datapath_id, self.n_buffers,
                          self.n_tables)
    packed += _PAD3
    packed += struct.pack("!LL", self.capabilities, self.actions)
    for i in self.ports:
      packed += i.pack()
    print ("pack ofp_features_reply")
    return packed

  def unpack (self, raw, offset=0):
    print (" tring to unpack ofp_features_reply")
    offset,length = self._unpack_header(raw, offset)
    offset,(self.datapath_id, self.n_buffers, self.n_tables) = \
        _unpack("!QLB", raw, offset)
    offset = _skip(raw, offset, 3)
    offset,(self.capabilities, self.actions) = _unpack("!LL", raw, offset)
    portCount = (length - 32) / len(ofp_phy_port)
    self.ports = []
    for i in xrange(0, portCount):
      p = ofp_phy_port()
      offset = p.unpack(raw, offset)
      self.ports.append(p)
    assert length == len(self)
    print ("unpack ofp_features_reply succ")
    return offset,length

  def __len__ (self):
    return 32 + len(self.ports) * len(ofp_phy_port)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.datapath_id != other.datapath_id: return False
    if self.n_buffers != other.n_buffers: return False
    if self.n_tables != other.n_tables: return False
    if self.capabilities != other.capabilities: return False
    if self.actions != other.actions: return False
    if self.ports != other.ports: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'datapath_id: ' + str(self.datapath_id) + '\n'
    outstr += prefix + 'n_buffers: ' + str(self.n_buffers) + '\n'
    outstr += prefix + 'n_tables: ' + str(self.n_tables) + '\n'
    outstr += prefix + 'capabilities: ' + str(self.capabilities) + '\n'
    outstr += prefix + 'actions: ' + str(self.actions) + '\n'
    outstr += prefix + 'ports: \n'
    for obj in self.ports:
      outstr += obj.show(prefix + '  ')
    return outstr
ofp_switch_features = ofp_features_reply

"""

##3.2 Switch Configuration
@openflow_c_message("OFPT_SET_CONFIG", 9)
class ofp_set_config (ofp_header): # uses ofp_switch_config
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.flags = 0
    self.miss_send_len = OFP_DEFAULT_MISS_SEND_LEN

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!HH", self.flags, self.miss_send_len)
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.flags, self.miss_send_len) = _unpack("!HH", raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 12

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.flags != other.flags: return False
    if self.miss_send_len != other.miss_send_len: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'flags: ' + str(self.flags) + '\n'
    outstr += prefix + 'miss_send_len: ' + str(self.miss_send_len) + '\n'
    return outstr


##3.3 Modify State Messages
@openflow_c_message("OFPT_FLOW_MOD", 15)
class ofp_flow_mod (ofp_header):       #modify by milktank
  _MIN_LENGTH = ofp_header._MIN_LENGTH + 40
  _MAX_LENGTH = ofp_header._MIN_LENGTH + 40 + ofp_matchx._MIN_LENGTH * OFP_MAX_MATCH_FIELD_NUM + \
  ofp_instruction._MAX_LENGTH * OFP_MAX_INSTRUCTION_NUM

  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.command = 0
    self.matchFieldNum = 0
    self.instructionNum = 0
    self.reserve = 0
    self.counterId = 0
    self.cookie = 0
    self.cookieMask = 0
    self.tableId = 0
    self.tableType = 0
    self.idleTimeout = 0
    self.hardTimeout = 0
    self.priority = OFP_DEFAULT_PRIORITY
    self.index = 0
    self.matchx =[]
    self.instruction =[] 
    initHelper(self, kw)

  def pack (self):
    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack ( "!B" ,self.command)
    packed += struct.pack ( "!B" ,len(self.matchx))
    packed += struct.pack ( "!B" ,len(self.instruction))
    packed += _PAD
    packed += struct.pack ( "!L" ,self.counterId)
    packed += struct.pack ( "!Q" ,self .cookie)
    packed += struct.pack ( "!Q" ,self .cookieMask)
    packed += struct.pack ( "!B" ,self .tableId)
    packed += struct.pack ( "!B" ,self .tableType)
    packed += struct.pack ( "!H" ,self .idleTimeout)
    packed += struct.pack ( "!H" ,self .hardTimeout)
    packed += struct.pack ( "!H" ,self .priority)
    packed += struct.pack ( "!L" ,self .index)
    packed += _PAD4
    
    numcount = 0
    for i in self.matchx:
        packed += i.pack()
        numcount += 1
    if (numcount < OFP_MAX_MATCH_FIELD_NUM):
        packed += _PAD * ((OFP_MAX_MATCH_FIELD_NUM - numcount) * ofp_matchx._MIN_LENGTH)
        
    numcount = 0
    for i in self.instruction:
        packed += i.pack()
        if (len(i)<ofp_instruction._MAX_LENGTH):
            packed += _PAD*(ofp_instruction._MAX_LENGTH - len(i) )
        numcount += 1
    if (numcount < OFP_MAX_INSTRUCTION_NUM):
        packed += _PAD * ((OFP_MAX_INSTRUCTION_NUM - numcount) * ofp_instruction._MAX_LENGTH)
    return packed
    
  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.command, self.matchFieldNum, self.instructionNum, self.reserve) = \
            _unpack("!BBBB", raw, offset)
    offset,(self.counterId, self.cookie, self.cookieMask, self.tableId, self .tableType) = \
            _unpack("!LQQBB", raw, offset)
    offset,(self.idleTimeout, self.hardTimeout, self.priority, self.index) = \
            _unpack("!HHLL", raw, offset)
    offset = _skip(raw, offset, 4)
    for i in xrange(0, OFP_MAX_MATCH_FIELD_NUM):
        p = ofp_matchx()
        offset = p.unpack(raw, offset)
        self.matchx.append(p)
    #how to unpack instruction list of different type instructions????????   
    assert length == len(self)
    return offset,length

  def __len__ (self):
    return ofp_flow_mod._MAX_LENGTH

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.match != other.match: return False
    if self.cookie != other.cookie: return False
    if self.command != other.command: return False
    if self.idle_timeout != other.idle_timeout: return False
    if self.hard_timeout != other.hard_timeout: return False
    if self.priority != other.priority: return False
    return True

  def show (self,prefix = '') :
    outstr = ''
    outstr += ofp_header.show (self, prefix + '  ')
    outstr += prefix + 'command: '+   str(self .command) + '\n'
    outstr += prefix + 'reserve: '+   str(self .reserve) + '\n'
    outstr += prefix + 'counterId: '+   str(self .counterId) + '\n'
    outstr += prefix + 'cookie: '+   str(self .cookie) + '\n'
    outstr += prefix + 'cookieMask: '+   str(self .cookieMask) + '\n'
    outstr += prefix + 'tableId: '+   str(self .tableId) + '\n'
    outstr += prefix + 'tableType: '+   str(self .tableType) + '\n'
    outstr += prefix + 'idleTimeout: '+   str(self .idleTimeout) + '\n'
    outstr += prefix + 'hardTimeout: '+   str(self .hardTimeout) + '\n'
    outstr += prefix + 'priority: '+   str(self .priority) + '\n'
    outstr += prefix + 'index: '+   str(self .index) + '\n'
    outstr += prefix + 'matchx: ' +   str(self .matchx) + '\n'
    outstr += prefix + 'instruction: '+   str(self .instruction) + '\n'
    return outstr


'''
@openflow_c_message("OFPT_PORT_MOD", 15)
class ofp_port_mod (ofp_header):   
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.port_no = 0
    self.hw_addr = EMPTY_ETH
    self.config = 0
    self.mask = 0
    self.advertise = 0

    initHelper(self, kw)

  def _validate (self):
    if (not isinstance(self.hw_addr, bytes)
        and not isinstance(self.hw_addr, EthAddr)):
      return "hw_addr is not bytes or EthAddr"
    if len(self.hw_addr) != 6:
      return "hw_addr is not of size 6"
    return None

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!H", self.port_no)
    if isinstance(self.hw_addr, bytes):
      packed += self.hw_addr
    else:
      packed += self.hw_addr.toRaw()
    packed += struct.pack("!LLL", self.config, self.mask, self.advertise)
    packed += _PAD4
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.port_no,) = _unpack("!H", raw, offset)
    offset,self.hw_addr = _readether(raw, offset)
    offset,(self.config, self.mask, self.advertise) = \
        _unpack("!LLL", raw, offset)
    offset = _skip(raw, offset, 4)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 32

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.port_no != other.port_no: return False
    if self.hw_addr != other.hw_addr: return False
    if self.config != other.config: return False
    if self.mask != other.mask: return False
    if self.advertise != other.advertise: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'port_no: ' + str(self.port_no) + '\n'
    outstr += prefix + 'hw_addr: ' + str(EthAddr(self.hw_addr)) + '\n'
    outstr += prefix + 'config: ' + str(self.config) + '\n'
    outstr += prefix + 'mask: ' + str(self.mask) + '\n'
    outstr += prefix + 'advertise: ' + str(self.advertise) + '\n'
    return outstr
'''

#3.3.3  
@openflow_c_message("OFPT_TABLE_MOD", 18)
class ofp_table_mod (ofp_header):    #add by milktank
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """


  _MIN_LENGTH = ofp_header._MIN_LENGTH+ofp_flow_table._MAX_LENGTH;


  def __init__(self,**kw):
    ofp_header.__init__(self)
    self.flowTable = ofp_flow_table()
    self.OFTableModCmd=0
    initHelper(self, kw)



  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other) : return False
    if self.flowTable != other.flowTable: return False
    return True


  def show(self,prefix=''):
    outstr =''
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'flowTable: '+  str(self.flowTable) + '\n' 
    return outstr



  def __repr__(self):
    return self.show()



  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()



  def __len__(self):
    return ofp_table_mod._MIN_LENGTH     ##Need to change to the correct length of the packet 



  def unpack(self,raw,offset=0):
    _offset = offset
    offset,length = self._unpack_header(raw, offset)
    offset=self.flowTable.unpack(raw, offset)
    assert offset - _offset == len(self)
    return offset,length



  def pack(self):
    #print ("Start to pack the tablemod")
    assert self._assert()
    packed=b""
    packed += ofp_header.pack(self)
    packed += self.flowTable.pack()
    return packed

#3.3.4
@openflow_c_message("OFPT_GROUP_MOD", 16)  #add by milktank
class ofp_group_mod (ofp_header):
  """
    This class is generated by Milktank_tool 
    @author:milktank
    @version:1.0
    @todo:

  """
  _MIN_LENGTH = ofp_header._MIN_LENGTH + 16
  _MAX_LENGTH = ofp_header._MIN_LENGTH + 16 + OFP_MAX_ACTION_NUMBER_PER_GROUP * ofp_action._MAX_LENGTH

  def __init__(self,**kw):
    ofp_header.__init__(self)
    self.command = 0
    self.groupType = 0
    self.actionNum = 0
    self.padding = 0
    self.groupId = 0
    self.counterId = 0
    self.padding = 0
    self.actions = []
    initHelper(self, kw)

  def __eq__(self,other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other) : return False
    if self.command != other.command: return False
    if self.groupType != other.groupType: return False
    if self.actionNum != other.actionNum: return False
    if self.padding != other.padding: return False
    if self.groupId != other.groupId: return False
    if self.counterId != other.counterId: return False
    if self.padding != other.padding: return False
    if self.actions != other.actions: return False
    return True

  def show(self,prefix=''):
    outstr =''
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'command: '+  str(self.command) + '\n' 
    outstr += prefix + 'groupType: '+  str(self.groupType) + '\n' 
    outstr += prefix + 'actionNum: '+  str(self.actionNum) + '\n' 
    outstr += prefix + 'padding: '+  str(self.padding) + '\n' 
    outstr += prefix + 'groupId: '+  str(self.groupId) + '\n' 
    outstr += prefix + 'counterId: '+  str(self.counterId) + '\n' 
    outstr += prefix + 'padding: '+  str(self.padding) + '\n' 
    outstr += prefix + 'actions: '+  str(self.actions) + '\n' 
    return outstr

  def __repr__(self):
    return self.show()

  def __str__(self):
    return self.__class__.__name__ + "\n  " + self.show('  ').strip()

  def __len__(self):
    return ofp_group_mod._MAX_LENGTH     ##Need to change to the correct length of the packet 

  def unpack(self,raw,offset=0):
    _offset = offset
    offset,length = self._unpack_header(raw, offset)
    offset,self.command = _unpack('!B', raw, offset)
    offset,self.groupType = _unpack('!B', raw, offset)
    offset,self.actionNum = _unpack('!B', raw, offset)
    offset,self.padding = _unpack('!B', raw, offset)
    offset,self.groupId = _unpack('!L', raw, offset)
    offset,self.counterId = _unpack('!L', raw, offset)
    offset,self.padding = _unpack('!B', raw, offset)
    for i in xrange(0,OFP_MAX_ACTION_NUMBER_PER_GROUP):
        temp_actions=ofp_action()
        offset = temp_actions.unpack(raw,offset)
        self.actions.append(temp_actions)
    assert offset - _offset == len(self)
    return offset,length

  def pack(self):
    assert self._assert()
    packed=b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!B" ,self.command)
    packed += struct.pack("!B" ,self.groupType)
    packed += struct.pack("!B" ,len(self.actions))
    packed += struct.pack("!B" ,self.padding)
    packed += struct.pack("!L" ,self.groupId)
    packed += struct.pack("!L" ,self.counterId)
    packed += _PAD4
    numcount =0
    for i in self.actions:
        packed += i.pack()
        if ofp_action._MAX_LENGTH > len (i ) :
            packed += _PAD*( ofp_action._MAX_LENGTH - len (i ))

        numcount +=1
    if (numcount < OFP_MAX_ACTION_NUMBER_PER_GROUP):
        packed += _PAD*((OFP_MAX_ACTION_NUMBER_PER_GROUP -numcount)*ofp_action._MAX_LENGTH)
    return packed


#3.3.5
@openflow_c_message("OFPT_PORT_MOD", 17)  #modify by milktank
class ofp_port_mod (ofp_header):
  _MIN_LENGTH=ofp_header._MIN_LENGTH + 8 + ofp_phy_port._MIN_LENGTH
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.reason = 0
    self.desc = ofp_phy_port()

    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.desc, ofp_phy_port):
      return "desc is not class ofp_phy_port"
    return None

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!B", self.reason)
    packed += _PAD * 7 # Pad
    packed += self.desc.pack()
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.reason,) = _unpack("!B", raw, offset)
    offset = _skip(raw, offset, 7)
    offset = self.desc.unpack(raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 136

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.reason != other.reason: return False
    if self.desc != other.desc: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'reason: ' + str(self.reason) + '\n'
    outstr += prefix + 'desc: \n'
    outstr += self.desc.show(prefix + '  ')
    return outstr

  def setByPortState(self,port_state):  #add to use the port_state to instance
    if not isinstance(port_state, ofp_port_status): return False
    self.reason = port_state.reason
    self.desc = port_state.desc
      
#3.3.6



##3.4 Queue Configuration Messages
@openflow_c_message("OFPT_QUEUE_GET_CONFIG_REQUEST", 23)  #modify by Tan, 20--->23
class ofp_queue_get_config_request (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.port = 0
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!H", self.port)
    packed += _PAD2
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.port,) = _unpack("!H", raw, offset)
    offset = _skip(raw, offset, 2)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 12

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.port != other.port: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'port: ' + str(self.port) + '\n'
    return outstr


@openflow_s_message("OFPT_QUEUE_GET_CONFIG_REPLY", 24)    #modify by Tan, 21--->24
class ofp_queue_get_config_reply (ofp_header):
  _MIN_LENGTH = 16
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.port = 0
    self.queues = []

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!H", self.port)
    packed += _PAD6
    for i in self.queues:
      packed += i.pack()
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.port,) = _unpack("!H", raw, offset)
    offset = _skip(raw, offset, 6)
    remaining = length - 6 - 2 - len(ofp_header)

    del self.queues[:]

    # Not tested; probably buggy
    while remaining > 0:
      q = ofp_packet_queue()
      _offset = q.unpack(raw, offset)
      l = _offset - offset
      offset = _offset
      if l < 1: raise RuntimeError("Can't parse")
      remaining -= l
      self.queues.append(q)

    assert length == len(self)
    return offset,length

  def __len__ (self):
    l = 16
    for i in self.queues:
      l += len(i)
    return l

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.port != other.port: return False
    if self.queues != other.queues: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'port: ' + str(self.port) + '\n'
    outstr += prefix + 'queues: \n'
    for obj in self.queues:
      outstr += obj.show(prefix + '  ')
    return outstr


@openflow_c_message("OFPT_STATS_REQUEST", 19)      #modify by Tan
class ofp_multipart_request (ofp_header):
#@openflow_c_message("OFPT_STATS_REQUEST", 16)     
#class ofp_stats_request (ofp_header):
  _MIN_LENGTH = 12
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.type = None # Try to guess
    self.flags = 0
    self._body = b''
    self._body_packed = None # Cache

    initHelper(self, kw)

  def pack (self):
    if self.type is None:
      if isinstance(self.body, ofp_stats_body_base):
        self.type = self.body._type
      else:
        raise RuntimeError("Can't determine body type; specify it "
                           + "explicitly")

    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!HH", self.type, self.flags)
    packed += self._pack_body()
    return packed

  def _pack_body (self):
    if self._body_packed is None:
      if hasattr(self.body, 'pack'):
        self._body_packed = self._body.pack()
      else:
        self._body_packed = self._body
    return self._body_packed

  @property
  def body (self):
    return self._body
  @body.setter
  def body (self, data):
    self._body = data
    self._body_packed_cache = None

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.type, self.flags) = _unpack("!HH", raw, offset)
    offset,body = _read(raw, offset, length - 12)
    si = _stats_type_to_class_info.get(self.type)
    if si is None:
      self.body = ofp_generic_stats_body()
      self.body.unpack(body, 0, len(body))
    else:
      if si.request is None:
        raise RuntimeError("No request for " + str(si))
      self.body = si.request()
      self.body.unpack(body, 0, len(body))
      #TODO: assert entire body is unpacked

    assert length == len(self)
    return offset,length

  def __len__ (self):
    return 12 + len(self._pack_body())

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.type != other.type: return False
    if self.flags != other.flags: return False
    if self._pack_body() != other._pack_body(): return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'flags: ' + str(self.flags) + '\n'
    outstr += prefix + 'body:\n'
    outstr += _format_body(self.body, prefix + '  ') + '\n'
    return outstr


@openflow_s_message("OFPT_STATS_REPLY", 20,       #modify by Tan
    reply_to="ofp_multipart_request")
class ofp_multipart_reply (ofp_header):
#@openflow_s_message("OFPT_STATS_REPLY", 18,
#    reply_to="ofp_stats_request")
  _MIN_LENGTH = 12
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.type = None # Guess
    self.flags = 0
    self.body = b''
    self._body_data = (None, None)

    initHelper(self, kw)

  @property
  def is_last_reply (self):
    return (self.flags & 1) == 0
  @is_last_reply.setter
  def is_last_reply (self, value):
    self.flags = self.flags & 0xfffe
    if not value:
      self.flags |= 1

  @property
  def body_data (self):
    if self._body_data[0] is not self.body:
      def _pack(b):
        return b.pack() if hasattr(b, 'pack') else b

      data = b''
      if isinstance(self.body, collections.Iterable):
        for b in self.body:
          data += _pack(b)
      else:
        data = _pack(self.body)
      self._body_data = (self.body, data)
    return self._body_data[1]

  def pack (self):
    if self.type is None:
      if isinstance(self.body, ofp_stats_body_base):
        self.type = self.body._type
      else:
        raise RuntimeError("Can't determine body type; specify it "
                           + "explicitly")

    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!HH", self.type, self.flags)
    packed += self.body_data
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.type, self.flags) = _unpack("!HH", raw, offset)
    offset,packed = _read(raw, offset, length - 12)
    t = _stats_type_to_class_info.get(self.type)
    if t is None:
      #FIXME: Put in a generic container?
      self.body = packed
    else:
      if t.reply is None:
        #FIXME: Put in a generic container?
        self.body = packed
      else:
        if not t.reply_is_list:
          self.body = t.reply()
          self.body.unpack(packed, 0, len(packed))
        else:
          prev_len = len(packed)
          self.body = []
          while len(packed):
            part = t.reply()
            off = part.unpack(packed, 0, len(packed))
            packed = packed[off:]
            assert len(packed) != prev_len
            prev_len = len(packed)
            self.body.append(part)

    assert length == len(self)
    return offset,length

  def __len__ (self):
    if isinstance(self.body, list):
      return 12 + sum(len(part) for part in self.body)
    return 12 + len(self.body)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.type != other.type: return False
    if self.flags != other.flags: return False
    if self.body != other.body: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'type: ' + str(self.type) + '\n'
    outstr += prefix + 'flags: ' + str(self.flags) + '\n'
    outstr += prefix + 'body:\n'
    outstr += _format_body(self.body, prefix + '  ') + '\n'
    return outstr



@openflow_stats_reply("OFPST_DESC", 0)
class ofp_desc_stats (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.mfr_desc= ""
    self.hw_desc= ""
    self.sw_desc= ""
    self.serial_num= ""
    self.dp_desc= ""

    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.mfr_desc, str):
      return "mfr_desc is not string"
    if len(self.mfr_desc) > DESC_STR_LEN:
      return "mfr_desc is not of size 256"
    if not isinstance(self.hw_desc, str):
      return "hw_desc is not string"
    if len(self.hw_desc) > DESC_STR_LEN:
      return "hw_desc is not of size 256"
    if not isinstance(self.sw_desc, str):
      return "sw_desc is not string"
    if len(self.sw_desc) > DESC_STR_LEN:
      return "sw_desc is not of size 256"
    if not isinstance(self.serial_num, str):
      return "serial_num is not string"
    if len(self.serial_num) > SERIAL_NUM_LEN:
      return "serial_num is not of size 32"
    if not isinstance(self.dp_desc, str):
      return "dp_desc is not string"
    if len(self.dp_desc) > DESC_STR_LEN:
      return "dp_desc is not of size 256"
    return None

  def pack (self):
    assert self._assert()

    packed = b""
    packed += self.mfr_desc.ljust(DESC_STR_LEN,'\0')
    packed += self.hw_desc.ljust(DESC_STR_LEN,'\0')
    packed += self.sw_desc.ljust(DESC_STR_LEN,'\0')
    packed += self.serial_num.ljust(SERIAL_NUM_LEN,'\0')
    packed += self.dp_desc.ljust(DESC_STR_LEN,'\0')
    return packed

  def unpack (self, raw, offset, avail):
    _offset = offset
    offset,self.mfr_desc   = _readzs(raw, offset, DESC_STR_LEN)
    offset,self.hw_desc    = _readzs(raw, offset, DESC_STR_LEN)
    offset,self.sw_desc    = _readzs(raw, offset, DESC_STR_LEN)
    offset,self.serial_num = _readzs(raw, offset, SERIAL_NUM_LEN)
    offset,self.dp_desc    = _readzs(raw, offset, DESC_STR_LEN)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 1056

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.mfr_desc != other.mfr_desc: return False
    if self.hw_desc != other.hw_desc: return False
    if self.sw_desc != other.sw_desc: return False
    if self.serial_num != other.serial_num: return False
    if self.dp_desc != other.dp_desc: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'mfr_desc: ' + str(self.mfr_desc) + '\n'
    outstr += prefix + 'hw_desc: ' + str(self.hw_desc) + '\n'
    outstr += prefix + 'sw_desc: ' + str(self.sw_desc) + '\n'
    outstr += prefix + 'serial_num: ' + str(self.serial_num) + '\n'
    outstr += prefix + 'dp_desc: ' + str(self.dp_desc) + '\n'
    return outstr

ofp_desc_stats_reply = ofp_desc_stats


# This next one is weird.  It only exists so that the type-guessing
# will work for requests.  I don't think it's really needed, though.
@openflow_stats_request('OFPST_DESC', 0)
class ofp_desc_stats_request (ofp_stats_body_base):
  def __init__ (self, **kw):
    pass

  def pack (self):
    return b""

  def unpack (self, raw, offset, avail):
    if avail != 0:
      raise RuntimeError("Expected empty body")
    return offset

  @staticmethod
  def __len__ ():
    return 0

  def __eq__ (self, other):
    if type(self) != type(other): return False
    return True

  def show (self, prefix=''):
    return "<empty>"


@openflow_stats_request('OFPST_FLOW', 1)
class ofp_flow_stats_request (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.match = ofp_match()
    self.table_id = TABLE_ALL
    self.out_port = OFPP_NONE
    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.match, ofp_match):
      return "match is not class ofp_match"
    return None

  def pack (self):
    assert self._assert()

    packed = b""
    packed += self.match.pack()
    packed += struct.pack("!BBH", self.table_id, 0, self.out_port)
    return packed

  def unpack (self, raw, offset, avail):
    _offset = offset
    offset = self.match.unpack(raw, offset)
    offset,(self.table_id, pad, self.out_port) = \
        _unpack("!BBH", raw, offset)
    assert pad == 0
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 4 + len(ofp_match)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.match != other.match: return False
    if self.table_id != other.table_id: return False
    if self.out_port != other.out_port: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'match: \n'
    outstr += self.match.show(prefix + '  ')
    outstr += prefix + 'table_id: ' + str(self.table_id) + '\n'
    outstr += prefix + 'out_port: ' + str(self.out_port) + '\n'
    return outstr


@openflow_stats_reply('OFPST_FLOW', is_list = True)
class ofp_flow_stats (ofp_stats_body_base):
  _MIN_LENGTH = 88
  def __init__ (self, **kw):
    self.table_id = 0
    self.match = ofp_match()
    self.duration_sec = 0
    self.duration_nsec = 0
    self.priority = OFP_DEFAULT_PRIORITY
    self.idle_timeout = 0
    self.hard_timeout = 0
    self.cookie = 0
    self.packet_count = 0
    self.byte_count = 0
    self.actions = []

    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.match, ofp_match):
      return "match is not class ofp_match"
    return None

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!HBB", len(self), self.table_id, 0)
    packed += self.match.pack()
    packed += struct.pack("!LLHHH", self.duration_sec,
                          self.duration_nsec, self.priority,
                          self.idle_timeout, self.hard_timeout)
    packed += _PAD6 # Pad
    packed += struct.pack("!QQQ", self.cookie, self.packet_count,
                          self.byte_count)
    for i in self.actions:
      packed += i.pack()
    return packed

  def unpack (self, raw, offset, avail):
    _offset = offset
    offset,(length, self.table_id, pad) = _unpack("!HBB", raw, offset)
    assert pad == 0
    offset = self.match.unpack(raw, offset)
    offset,(self.duration_sec, self.duration_nsec, self.priority,
            self.idle_timeout, self.hard_timeout) = \
            _unpack("!LLHHH", raw, offset)
    offset = _skip(raw, offset, 6)
    offset,(self.cookie, self.packet_count, self.byte_count) = \
        _unpack("!QQQ", raw, offset)
    assert (offset - _offset) == 48 + len(self.match)
    offset,self.actions = _unpack_actions(raw,
        length - (48 + len(self.match)), offset)
    assert offset - _offset == len(self)
    return offset

  def __len__ (self):
    l = 48 + len(self.match)
    for i in self.actions:
      l += len(i)
    return l

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if len(self) != len(other): return False
    if self.table_id != other.table_id: return False
    if self.match != other.match: return False
    if self.duration_sec != other.duration_sec: return False
    if self.duration_nsec != other.duration_nsec: return False
    if self.priority != other.priority: return False
    if self.idle_timeout != other.idle_timeout: return False
    if self.hard_timeout != other.hard_timeout: return False
    if self.cookie != other.cookie: return False
    if self.packet_count != other.packet_count: return False
    if self.byte_count != other.byte_count: return False
    if self.actions != other.actions: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'length: ' + str(len(self)) + '\n'
    outstr += prefix + 'table_id: ' + str(self.table_id) + '\n'
    outstr += prefix + 'match: \n'
    outstr += self.match.show(prefix + '  ')
    outstr += prefix + 'duration_sec: ' + str(self.duration_sec) + '\n'
    outstr += prefix + 'duration_nsec: ' + str(self.duration_nsec) + '\n'
    outstr += prefix + 'priority: ' + str(self.priority) + '\n'
    outstr += prefix + 'idle_timeout: ' + str(self.idle_timeout) + '\n'
    outstr += prefix + 'hard_timeout: ' + str(self.hard_timeout) + '\n'
    outstr += prefix + 'cookie: ' + str(self.cookie) + '\n'
    outstr += prefix + 'packet_count: ' + str(self.packet_count) + '\n'
    outstr += prefix + 'byte_count: ' + str(self.byte_count) + '\n'
    outstr += prefix + 'actions: \n'
    for obj in self.actions:
      outstr += obj.show(prefix + '  ')
    return outstr
ofp_flow_stats_reply = ofp_flow_stats


@openflow_stats_request('OFPST_AGGREGATE', 2)
class ofp_aggregate_stats_request (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.match = ofp_match()
    self.table_id = TABLE_ALL
    self.out_port = OFPP_NONE

    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.match, ofp_match):
      return "match is not class ofp_match"
    return None

  def pack (self):
    assert self._assert()

    packed = b""
    packed += self.match.pack()
    packed += struct.pack("!BBH", self.table_id, 0, self.out_port)
    return packed

  def unpack (self, raw, offset, avail):
    _offset = offset
    offset = self.match.unpack(raw, offset)
    offset,(self.table_id, pad, self.out_port) = \
        _unpack("!BBH", raw, offset)
    assert pad == 0
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 44

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.match != other.match: return False
    if self.table_id != other.table_id: return False
    if self.out_port != other.out_port: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'match: \n'
    outstr += self.match.show(prefix + '  ')
    outstr += prefix + 'table_id: ' + str(self.table_id) + '\n'
    outstr += prefix + 'out_port: ' + str(self.out_port) + '\n'
    return outstr


@openflow_stats_reply('OFPST_AGGREGATE')
class ofp_aggregate_stats (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.packet_count = 0
    self.byte_count = 0
    self.flow_count = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!QQL", self.packet_count, self.byte_count,
                          self.flow_count)
    packed += _PAD4 # Pad
    return packed

  def unpack (self, raw, offset, avail):
    _offset = offset
    offset,(self.packet_count, self.byte_count, self.flow_count) = \
        _unpack("!QQL", raw, offset)
    offset = _skip(raw, offset, 4)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 24

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.packet_count != other.packet_count: return False
    if self.byte_count != other.byte_count: return False
    if self.flow_count != other.flow_count: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'packet_count: ' + str(self.packet_count) + '\n'
    outstr += prefix + 'byte_count: ' + str(self.byte_count) + '\n'
    outstr += prefix + 'flow_count: ' + str(self.flow_count) + '\n'
    return outstr
ofp_aggregate_stats_reply = ofp_aggregate_stats


@openflow_stats_reply('OFPST_TABLE', 3, is_list = True)
class ofp_table_stats (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.table_id = 0
    self.name = ""
    self.wildcards = 0
    self.max_entries = 0
    self.active_count = 0
    self.lookup_count = 0
    self.matched_count = 0

    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.name, str):
      return "name is not string"
    if len(self.name) > OFP_MAX_TABLE_NAME_LEN:
      return "name is too long"
    return None

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!B", self.table_id)
    packed += _PAD3
    packed += self.name.ljust(OFP_MAX_TABLE_NAME_LEN,'\0')
    packed += struct.pack("!LLLQQ", self.wildcards, self.max_entries,
                          self.active_count, self.lookup_count,
                          self.matched_count)
    return packed

  def unpack (self, raw, offset, avail):
    _offset = offset
    offset,(self.table_id,) = _unpack("!B", raw, offset)
    offset = _skip(raw, offset, 3)
    offset,self.name = _readzs(raw, offset, OFP_MAX_TABLE_NAME_LEN)
    offset,(self.wildcards, self.max_entries, self.active_count,
            self.lookup_count, self.matched_count) = \
            _unpack("!LLLQQ", raw, offset)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 64

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.table_id != other.table_id: return False
    if self.name != other.name: return False
    if self.wildcards != other.wildcards: return False
    if self.max_entries != other.max_entries: return False
    if self.active_count != other.active_count: return False
    if self.lookup_count != other.lookup_count: return False
    if self.matched_count != other.matched_count: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'table_id: ' + str(self.table_id) + '\n'
    outstr += prefix + 'name: ' + str(self.name) + '\n'
    outstr += prefix + 'wildcards: ' + str(self.wildcards) + '\n'
    outstr += prefix + 'max_entries: ' + str(self.max_entries) + '\n'
    outstr += prefix + 'active_count: ' + str(self.active_count) + '\n'
    outstr += prefix + 'lookup_count: ' + str(self.lookup_count) + '\n'
    outstr += prefix + 'matched_count: ' + str(self.matched_count) + '\n'
    return outstr
ofp_table_stats_reply = ofp_table_stats


@openflow_stats_request("OFPST_PORT", 4)
class ofp_port_stats_request (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.port_no = OFPP_NONE
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!H", self.port_no)
    packed += _PAD6
    return packed

  def unpack (self, raw, offset, avail):
    _offset = offset
    offset,(self.port_no,) = _unpack("!H", raw, offset)
    offset = _skip(raw, offset, 6)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.port_no != other.port_no: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'port_no: ' + str(self.port_no) + '\n'
    return outstr


@openflow_stats_reply("OFPST_PORT", is_list = True)
class ofp_port_stats (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.port_no = OFPP_NONE
    self.rx_packets = 0
    self.tx_packets = 0
    self.rx_bytes = 0
    self.tx_bytes = 0
    self.rx_dropped = 0
    self.tx_dropped = 0
    self.rx_errors = 0
    self.tx_errors = 0
    self.rx_frame_err = 0
    self.rx_over_err = 0
    self.rx_crc_err = 0
    self.collisions = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!H", self.port_no)
    packed += _PAD6
    packed += struct.pack("!QQQQQQQQQQQQ", self.rx_packets,
                          self.tx_packets, self.rx_bytes, self.tx_bytes,
                          self.rx_dropped, self.tx_dropped,
                          self.rx_errors, self.tx_errors,
                          self.rx_frame_err, self.rx_over_err,
                          self.rx_crc_err, self.collisions)
    return packed

  def unpack (self, raw, offset, avail):
    _offset = offset
    offset,(self.port_no,) = _unpack("!H", raw, offset)
    offset = _skip(raw, offset, 6)
    offset,(self.rx_packets, self.tx_packets, self.rx_bytes,
            self.tx_bytes, self.rx_dropped, self.tx_dropped,
            self.rx_errors, self.tx_errors, self.rx_frame_err,
            self.rx_over_err, self.rx_crc_err, self.collisions) = \
            _unpack("!QQQQQQQQQQQQ", raw, offset)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 104

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.port_no != other.port_no: return False
    if self.rx_packets != other.rx_packets: return False
    if self.tx_packets != other.tx_packets: return False
    if self.rx_bytes != other.rx_bytes: return False
    if self.tx_bytes != other.tx_bytes: return False
    if self.rx_dropped != other.rx_dropped: return False
    if self.tx_dropped != other.tx_dropped: return False
    if self.rx_errors != other.rx_errors: return False
    if self.tx_errors != other.tx_errors: return False
    if self.rx_frame_err != other.rx_frame_err: return False
    if self.rx_over_err != other.rx_over_err: return False
    if self.rx_crc_err != other.rx_crc_err: return False
    if self.collisions != other.collisions: return False
    return True

  def __add__(self, other):
    if type(self) != type(other): raise NotImplemented()
    port_no = OFPP_NONE
    if self.port_no == other.port_no:
      port_no = self.port_no
    return ofp_port_stats(
        port_no=port_no,
        rx_packets = self.rx_packets + other.rx_packets,
        tx_packets = self.tx_packets + other.tx_packets,
        rx_bytes = self.rx_bytes + other.rx_bytes,
        tx_bytes = self.tx_bytes + other.tx_bytes,
        rx_dropped = self.rx_dropped + other.rx_dropped,
        tx_dropped = self.tx_dropped + other.tx_dropped,
        rx_errors = self.rx_errors + other.rx_errors,
        tx_errors = self.tx_errors + other.tx_errors,
        rx_frame_err = self.rx_frame_err + other.rx_frame_err,
        rx_over_err = self.rx_over_err + other.rx_over_err,
        rx_crc_err = self.rx_crc_err + other.rx_crc_err,
        collisions = self.collisions + other.collisions)

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'port_no: ' + str(self.port_no) + '\n'
    outstr += prefix + 'rx_packets: ' + str(self.rx_packets) + '\n'
    outstr += prefix + 'tx_packets: ' + str(self.tx_packets) + '\n'
    outstr += prefix + 'rx_bytes: ' + str(self.rx_bytes) + '\n'
    outstr += prefix + 'tx_bytes: ' + str(self.tx_bytes) + '\n'
    outstr += prefix + 'rx_dropped: ' + str(self.rx_dropped) + '\n'
    outstr += prefix + 'tx_dropped: ' + str(self.tx_dropped) + '\n'
    outstr += prefix + 'rx_errors: ' + str(self.rx_errors) + '\n'
    outstr += prefix + 'tx_errors: ' + str(self.tx_errors) + '\n'
    outstr += prefix + 'rx_frame_err: ' + str(self.rx_frame_err) + '\n'
    outstr += prefix + 'rx_over_err: ' + str(self.rx_over_err) + '\n'
    outstr += prefix + 'rx_crc_err: ' + str(self.rx_crc_err) + '\n'
    outstr += prefix + 'collisions: ' + str(self.collisions) + '\n'
    return outstr
ofp_port_stats_reply = ofp_port_stats


@openflow_stats_request("OFPST_QUEUE", 5)
class ofp_queue_stats_request (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.port_no = OFPP_ALL
    self.queue_id = OFPQ_ALL

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!H", self.port_no)
    packed += _PAD2
    packed += struct.pack("!L", self.queue_id)
    return packed

  def unpack (self, raw, offset, avail):
    _offset = offset
    offset,(self.port_no,pad,self.queue_id) = _unpack("!HHL", raw, offset)
    assert pad == 0
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.port_no != other.port_no: return False
    if self.queue_id != other.queue_id: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'port_no: ' + str(self.port_no) + '\n'
    outstr += prefix + 'queue_id: ' + str(self.queue_id) + '\n'
    return outstr


@openflow_stats_reply("OFPST_QUEUE", is_list = True)
class ofp_queue_stats (ofp_stats_body_base):
  def __init__ (self, **kw):
    self.port_no = 0
    self.queue_id = 0
    self.tx_bytes = 0
    self.tx_packets = 0
    self.tx_errors = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!H", self.port_no)
    packed += _PAD2
    packed += struct.pack("!LQQQ", self.queue_id, self.tx_bytes,
                          self.tx_packets, self.tx_errors)
    return packed

  def unpack (self, raw, offset, avail):
    _offset = offset
    offset,(self.port_no, pad, self.queue_id, self.tx_bytes,
            self.tx_packets, self.tx_errors) = \
            _unpack("!HHLQQQ", raw, offset)
    assert offset - _offset == len(self)
    return offset

  @staticmethod
  def __len__ ():
    return 32

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.port_no != other.port_no: return False
    if self.queue_id != other.queue_id: return False
    if self.tx_bytes != other.tx_bytes: return False
    if self.tx_packets != other.tx_packets: return False
    if self.tx_errors != other.tx_errors: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'port_no: ' + str(self.port_no) + '\n'
    outstr += prefix + 'queue_id: ' + str(self.queue_id) + '\n'
    outstr += prefix + 'tx_bytes: ' + str(self.tx_bytes) + '\n'
    outstr += prefix + 'tx_packets: ' + str(self.tx_packets) + '\n'
    outstr += prefix + 'tx_errors: ' + str(self.tx_errors) + '\n'
    return outstr
ofp_queue_stats_reply = ofp_queue_stats


@openflow_stats_request("OFPST_VENDOR", 65535, is_list = False)
@openflow_stats_reply("OFPST_VENDOR", 65535, is_list = False)
class ofp_vendor_stats_generic (ofp_stats_body_base):
  _MIN_LENGTH = 4
  def __init__ (self, **kw):
    self.vendor = None
    self.data = b""

    initHelper(self, kw)

  def _pack_body (self):
    if hasattr(self.data, "pack"):
      return self.data.pack()
    else:
      return self.data

  def pack (self):
    assert self._assert()

    packed = struct.pack("!L", self.vendor)
    packed += self._pack_body()
    return packed

  def unpack (self, raw, offset, avail):
    if avail is None: RuntimeError("Requires length")
    _offset = offset
    offset,(self.vendor,) = _unpack("!L", raw, offset)
    offset,self.data = _read(raw, offset, avail-4)
    return offset

  @staticmethod
  def __len__ ():
    return 4+len(self._pack_body())

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.vendor != other.vendor: return False
    if self.data != other.data: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'vendor id: ' + str(self.vendor) + '\n'
    outstr += prefix + 'data len: ' + str(len(self.data)) + '\n'
    return outstr


class ofp_generic_stats_body (ofp_stats_body_base):
  _MIN_LENGTH = 0
  def __init__ (self, **kw):
    self.data = b""

    initHelper(self, kw)

  def _pack_body (self):
    if hasattr(self.data, "pack"):
      return self.data.pack()
    else:
      return self.data

  def pack (self):
    assert self._assert()

    packed += self._pack_body()
    return packed

  def unpack (self, raw, offset, avail):
    if avail is None: RuntimeError("Requires length")
    _offset = offset
    offset,self.data = _read(raw, offset, avail)
    return offset

  @staticmethod
  def __len__ ():
    return len(self._pack_body())

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.data != other.data: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'data len: ' + str(len(self.data)) + '\n'
    return outstr


@openflow_c_message("OFPT_PACKET_OUT", 14)
class ofp_packet_out (ofp_header): #change to avoid collision by milktank
  _MIN_LENGTH = 16
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self._buffer_id = NO_BUFFER
    self.in_port = OFPP_NONE
    self.actions = []
    self._data = b''

    # ofp_flow_mod & ofp_packet_out do some special handling of 'actions'

    # Allow "action" as a synonym for "actions"
    if 'action' in kw and 'actions' not in kw:
      kw['actions'] = kw['action']
      del kw['action']
    initHelper(self, kw)

    # Allow use of actions=<a single action> for kw args.
    if not hasattr(self.actions, '__getitem__'):
      self.actions = [self.actions]

  @property
  def buffer_id (self):
    if self._buffer_id == NO_BUFFER: return None
    return self._buffer_id
  @buffer_id.setter
  def buffer_id (self, val):
    if val is None: val = NO_BUFFER
    self._buffer_id = val

  @property
  def data (self):
    return self._data
  @data.setter
  def data (self, data):
    if data is None:
      self._data = b''
    elif isinstance(data, packet_base):
      self._data = data.pack()
    elif isinstance(data, ofp_packet_in):
      # Enable you to easily resend a packet
      self._data = b''
      self.buffer_id = data.buffer_id
      if self.buffer_id is None:
        #TODO: It'd be nice to log and then ignore if data is incomplete
        #      Unfortunately, we currently have no logging in here, so we
        #      assert instead which is a either too drastic or too quiet.
        assert data.is_complete
        self._data = data._data
      self.in_port = data.in_port
    elif isinstance(data, bytes):
      self._data = data
    assert assert_type("data", self._data, (bytes,))

  def _validate (self):
    if self.buffer_id is not None and self.data != b'':
      return "can not have both buffer_id and data set"
    return None

  def pack (self):
    assert self._assert()

    actions = b''.join((i.pack() for i in self.actions))
    actions_len = len(actions)

    if self.data is not None:
      return b''.join((ofp_header.pack(self),
        struct.pack("!LHH", self._buffer_id, self.in_port, actions_len),
        actions, self.data))
    else:
      return b''.join((ofp_header.pack(self),
      struct.pack("!LHH", self._buffer_id, self.in_port, actions_len),
      actions))

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,length = self._unpack_header(raw, offset)
    offset,(self._buffer_id, self.in_port, actions_len) = \
        _unpack("!LHH", raw, offset)
    offset,self.actions = _unpack_actions(raw, actions_len, offset)

    remaining = length - (offset - _offset)
    if remaining <= 0:
      self.data = None
    else:
      offset,self.data = _read(raw, offset, remaining)

    assert length == len(self)
    return offset,length

  def __len__ (self):
    return 16 + reduce(operator.add, (len(a) for a in self.actions),
        0) + (len(self.data) if self.data else 0)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.buffer_id != other.buffer_id: return False
    if self.in_port != other.in_port: return False
    if self.actions != other.actions: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'buffer_id: ' + str(self.buffer_id) + '\n'
    outstr += prefix + 'in_port: ' + str(self.in_port) + '\n'
    outstr += prefix + 'actions_len: ' + str(len(self.actions)) + '\n'
    outstr += prefix + 'actions: \n'
    for obj in self.actions:
      if obj is None:
        raise RuntimeError("An element of self.actions was None! "
                           + "Bad formatting...")
      outstr += obj.show(prefix + '  ')
    return outstr


##3.7 Barrier Message
@openflow_s_message("OFPT_BARRIER_REPLY", 22,  #modify by Tan, 19--->22 
    reply_to="ofp_barrier_request")
class ofp_barrier_reply (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    return packed

  #def unpack (self, raw, offset=0):
  #  offset,length = self._unpack_header(raw, offset)
  #  assert length == len(self)
  #  return offset,length

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr


@openflow_c_message("OFPT_BARRIER_REQUEST", 21,  #modify by Tan, 18--->21
    request_for="ofp_barrier_reply")
class ofp_barrier_request (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    return packed

  #def unpack (self, raw, offset=0):
  #  offset,length = self._unpack_header(raw, offset)
  #  assert length == len(self)
  #  return offset,length

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr


#4 Asynchronous Messages
"""
@openflow_s_message("OFPT_PACKET_IN", 10)
class ofp_packet_in (ofp_header):
  _MIN_LENGTH = 18
  def __init__ (self, **kw):
    ofp_header.__init__(self)

    self.in_port = OFPP_NONE
    self._buffer_id = NO_BUFFER
    self.reason = 0
    self.data = None
    self._total_len = None

    if 'total_len' in kw:
      self._total_len = kw.pop('total_len')

    initHelper(self, kw)

  def _validate (self):
    if self.data and (self.total_len < len(self.data)):
      return "total len less than data len"

  @property
  def total_len (self):
    if self._total_len is None:
      return len(self.data) if self.data else 0
    return self._total_len

  @total_len.setter
  def total_len (self, value):
    self._total_len = value

  @property
  def buffer_id (self):
    if self._buffer_id == NO_BUFFER: return None
    return self._buffer_id
  @buffer_id.setter
  def buffer_id (self, val):
    if val is None: val = NO_BUFFER
    self._buffer_id = val

  @property
  def data (self):
    return self._data
  @data.setter
  def data (self, data):
    assert assert_type("data", data, (packet_base, str))
    if data is None:
      self._data = ''
    elif isinstance(data, packet_base):
      self._data = data.pack()
    else:
      self._data = data

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!LHHBB", self._buffer_id, self.total_len,
                          self.in_port, self.reason, 0)
    packed += self.data
    #TODO: Padding?  See __len__
    return packed

  @property
  def is_complete (self):
    if self.buffer_id is not None: return True
    return len(self.data) == self.total_len

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self._buffer_id, self._total_len, self.in_port, self.reason,
            pad) = _unpack("!LHHBB", raw, offset)
    offset,self.data = _read(raw, offset, length-18)
    assert length == len(self)
    return offset,length

  def __len__ (self):
    #FIXME: This is probably wrong, but it's not clear from the
    #       spec what's supposed to be going on here.
    #if len(self.data) < 2:
    #  return 20 + len(self.data)
    return 18 + len(self.data)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.buffer_id != other.buffer_id: return False
    if self.total_len != other.total_len: return False
    if self.in_port != other.in_port: return False
    if self.reason != other.reason: return False
    if self.data != other.data: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'buffer_id: ' + str(self.buffer_id) + '\n'
    outstr += prefix + 'total_len: ' + str(self._total_len) + '\n'
    outstr += prefix + 'in_port: ' + str(self.in_port) + '\n'
    outstr += prefix + 'reason: ' + str(self.reason) + '\n'
    outstr += prefix + 'data: ' + str(self.data) + '\n'
    return outstr
"""
@openflow_s_message("OFPT_PACKET_IN", 10)     #modify by Tan
class ofp_packet_in (ofp_header):
  _MIN_LENGTH = 32
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.bufferId = 0
    self.totalLength = 0
    self.reason = 0
    self.tableId = 0
    self.cookie = 0
    self.deviceId = 0
    #self.reverse = 0
    self.slotID = 0
    self.port_id= 0
    self.packetData = b''
    


  def pack (self):
    assert self._assert()
    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!LHBBQLHH", self.bufferId, self.totalLength,self.reason, self.tableId, \
                          self.cookie, self.deviceId, self.slotID,self.port_id)
    #for i in range(self.totalLength):
        #packed += struct.pack("!B",self.packetData[i])
    packed += self.packetData
    return packed


  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.bufferId, self.totalLength,self.reason, self.tableId, \
             self.cookie, self.deviceId, self.slotID,self.port_id) = _unpack("!LHBBQLHH", raw, offset)
    offset,self.packetData = _read(raw, offset, self.totalLength)        
    assert length == len(self)
    return offset,length

  def __len__ (self):
    return 32 + len(self.packetData)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.bufferId != other.bufferId: return False
    if self.totalLength != other.totalLength: return False
    if self.reason != other.reason: return False
    if self.tableId != other.tableId: return False
    if self.cookie != other.cookie: return False
    if self.deviceId != other.deviceId: return False
    if self.slotID != other.slotID: return False
    if self.port_id != other.port_id: return False
    #if self.reverse != other.reverse: return False
    if self.packetData != other.packetData: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'bufferId: ' + str(self.bufferId) + '\n'
    outstr += prefix + 'totalLength: ' + str(self.totalLength) + '\n'
    outstr += prefix + 'reason: ' + str(self.reason) + '\n'
    outstr += prefix + 'tableId: ' + str(self.tableId) + '\n'
    outstr += prefix + 'cookie: ' + str(self.cookie) + '\n'
    outstr += prefix + 'deviceId: ' + str(self.deviceId) + '\n'
#     outstr += prefix + 'reverse: ' + str(self.reverse) + '\n'
    outstr += prefix + 'cookie: ' + str(self.cookie) + '\n'
    outstr += prefix + 'slotID: ' + str(self.slotID) + '\n'
    outstr += prefix + 'port_id: ' + str(self.port_id) + '\n'
    if len(self.packetData):
      outstr += prefix + 'packetData:\n' 
      outstr += prefix + hexdump(self.packetData).replace("\n", "\n" + prefix)
    return outstr


@openflow_s_message("OFPT_FLOW_REMOVED", 11)
class ofp_flow_removed (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.match = ofp_match()
    self.cookie = 0
    self.priority = 0
    self.reason = 0
    self.duration_sec = 0
    self.duration_nsec = 0
    self.idle_timeout = 0
    self.packet_count = 0
    self.byte_count = 0
    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.match, ofp_match):
      return "match is not class ofp_match"
    return None

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += self.match.pack()
    packed += struct.pack("!QHB", self.cookie, self.priority, self.reason)
    packed += _PAD
    packed += struct.pack("!LLH", self.duration_sec, self.duration_nsec,
                          self.idle_timeout)
    packed += _PAD2
    packed += struct.pack("!QQ", self.packet_count, self.byte_count)
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset = self.match.unpack(raw, offset)
    offset,(self.cookie, self.priority, self.reason) = \
        _unpack("!QHB", raw, offset)
    offset = _skip(raw, offset, 1)
    offset,(self.duration_sec, self.duration_nsec, self.idle_timeout) = \
        _unpack("!LLH", raw, offset)
    offset = _skip(raw, offset, 2)
    offset,(self.packet_count, self.byte_count) = \
        _unpack("!QQ", raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 48 + len(ofp_match)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.match != other.match: return False
    if self.cookie != other.cookie: return False
    if self.priority != other.priority: return False
    if self.reason != other.reason: return False
    if self.duration_sec != other.duration_sec: return False
    if self.duration_nsec != other.duration_nsec: return False
    if self.idle_timeout != other.idle_timeout: return False
    if self.packet_count != other.packet_count: return False
    if self.byte_count != other.byte_count: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'match: \n'
    outstr += self.match.show(prefix + '  ')
    outstr += prefix + 'cookie: ' + str(self.cookie) + '\n'
    outstr += prefix + 'priority: ' + str(self.priority) + '\n'
    outstr += prefix + 'reason: ' + str(self.reason) + '\n'
    outstr += prefix + 'duration_sec: ' + str(self.duration_sec) + '\n'
    outstr += prefix + 'duration_nsec: ' + str(self.duration_nsec) + '\n'
    outstr += prefix + 'idle_timeout: ' + str(self.idle_timeout) + '\n'
    outstr += prefix + 'packet_count: ' + str(self.packet_count) + '\n'
    outstr += prefix + 'byte_count: ' + str(self.byte_count) + '\n'
    return outstr


@openflow_s_message("OFPT_PORT_STATUS", 12)
class ofp_port_status (ofp_header):  ##milktank modifly to avoid the collison with pof 
  _MIN_LENGTH=ofp_header._MIN_LENGTH + 8 + ofp_phy_port._MIN_LENGTH
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.reason = 0
    self.desc = ofp_phy_port()

    initHelper(self, kw)

  def _validate (self):
    if not isinstance(self.desc, ofp_phy_port):
      return "desc is not class ofp_phy_port"
    return None

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!B", self.reason)
    packed += _PAD * 7 # Pad
    packed += self.desc.pack()
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.reason,) = _unpack("!B", raw, offset)
    offset = _skip(raw, offset, 7)
    offset = self.desc.unpack(raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 136

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.reason != other.reason: return False
    if self.desc != other.desc: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'reason: ' + str(self.reason) + '\n'
    outstr += prefix + 'desc: \n'
    outstr += self.desc.show(prefix + '  ')
    return outstr

@openflow_s_message("OFPT_RESOURCE_REPORT", 13,
    reply_to="ofp_get_config_request")  ##reply_to="ofp_get_config_request" ??? not sure
class ofp_resource_report(ofp_header): # uses ofp_switch_resource_report
  """
    @author: milktank
    @version: 1.0 
    @contact: add new msg :OFPT_RESOURCE_REPORT 13
    @edit_time:2014-10-1 14:31:43
  """
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.pof_flowTableResource=ofp_flow_table_resource()

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!HH", self.flags, self.miss_send_len)
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset=self.pof_flowTableResource.unpack(raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 88

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.pof_flowTableResource != other.pof_flowTableResource: return False
    
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'ofp_flow_table_resource: ' + str(self.pof_flowTableResource) + '\n'
    return outstr


@openflow_s_message("OFPT_ERROR", 1)
class ofp_error (ofp_header):   #modify by Tan
  _MIN_LENGTH = 16    
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.type = 0
    self.code = 0
    self.deviceID = 0  #add by Tan
    self.data = b''

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!HHL", self.type, self.code, self.deviceID) #modify by Tan
    packed += self.data
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.type, self.code, self.deviceID) = _unpack("!HHL", raw, offset)  #modify by Tan
    offset,self.data = _read(raw, offset, length - 16)
    #print ('???????????????????', self.data)
    assert length == len(self)
    return offset,length

  def __len__ (self):
    return 16 + len(self.data)   #modify by Tan

  def __eq__ (self, other):   
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.type != other.type: return False
    if self.code != other.code: return False
    if self.deviceID != other.deviceID: return False   #modify by Tan
    if self.data != other.data: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    t = self.type
    c = self.code
    if t < len(ofp_error_type):
      n = ofp_error_type_map[t]
      t = "%s (%i)" % (n, t)
      n = 'ofp' + n.lower()[5:] + '_code_map'
      if n in sys.modules[__name__].__dict__:
        if c in sys.modules[__name__].__dict__[n]:
          c = "%s (%i)" % (sys.modules[__name__].__dict__[n][c], c)
    outstr += prefix + 'type: ' + str(t) + '\n'
    outstr += prefix + 'code: ' + str(c) + '\n'
    outstr += prefix + 'deviceID: ' + str(self.deviceID) + '\n'   #Add by Tan
    if len(self.data):
      outstr += prefix + 'datalen: %s\n' % (len(self.data),)
      outstr += prefix + hexdump(self.data).replace("\n", "\n" + prefix)
    return outstr.strip()

@openflow_s_message("GET_ASYNC_REQUEST", 27)  #add by Tan
class ofp_get_async_request(ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr

@openflow_s_message("GET_ASYNC_REPLY", 28)   #add by Tan
class ofp_get_async_reply(ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr

@openflow_s_message("SET_ASYNC", 29)   #add by Tan
class ofp_set_async(ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr


#5. Symmetric Messages
@openflow_sc_message("OFPT_HELLO", 0)
class ofp_hello (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    #print ("pack ofp_hello")
    return packed

  #def unpack (self, raw, offset=0):
  #  offset,length = self._unpack_header(raw, offset)
  #  assert length == len(self)
  #  return offset,length

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr


@openflow_sc_message("OFPT_ECHO_REQUEST", 2,
    request_for="ofp_echo_reply")
class ofp_echo_request (ofp_header):
  _MIN_LENGTH = 8
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.body = b''
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += self.body
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,self.body = _read(raw, offset, length - 8)
    assert length == len(self)
    
    #print ("unpack ofp_echo_request")
    return offset,length

  def __len__ (self):
    return 8 + len(self.body)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.body != other.body: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'body:\n'
    outstr += _format_body(self.body, prefix + '  ') + '\n'
    return outstr


@openflow_sc_message("OFPT_ECHO_REPLY", 3,
    reply_to="ofp_echo_request")
class ofp_echo_reply (ofp_header):
  _MIN_LENGTH = 8
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.body = b''
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += self.body
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,self.body = _read(raw, offset, length - 8)
    assert length == len(self)
    return offset,length

  def __len__ (self):
    return 8 + len(self.body)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.body != other.body: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'body:\n'
    outstr += _format_body(self.body, prefix + '  ') + '\n'
    return outstr


class ofp_vendor_base (ofp_header):
  header_type = 4 # OFPT_VENDOR
  """
  Base class for vendor messages
  """
  pass


@openflow_sc_message("OFPT_VENDOR", 4)       #modify by Tan
#class ofp_vendor_generic (ofp_vendor_base):
class ofp_experimenter (ofp_vendor_base):
  _MIN_LENGTH = 12
  _collect_raw = False

  def __init__ (self, **kw):
    ofp_header.__init__(self)
    #self.vendor = 0       #modify by Tan
    #self.data = b''       #modify by Tan
    self.experimenter = 0
    self.experimenterData = b''
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!L", self.experimenter)
    if hasattr(self.experimenterData, "pack"):
      packed += self.experimenterData.pack()
    else:
      packed += self.experimenterData
    return packed

  def unpack (self, raw, offset=0):
    _offset = offset
    offset,length = self._unpack_header(raw, offset)
    offset,(self.experimenter,) = _unpack("!L", raw, offset)
    offset,self.experimenterData = _read(raw, offset, length-12)
    if self._collect_raw:
      self.raw = raw[_offset, _offset+length]
    return offset,length

  def __len__ (self):
    return 12 + len(self.experimenterData)

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.experimenter != other.experimenter: return False
    if self.experimenterData != other.experimenterData: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'experimenter: ' + str(self.experimenter) + '\n'
    outstr += prefix + 'datalen: ' + str(len(self.experimenterData)) + '\n'
    #outstr += prefix + hexdump(self.data).replace("\n", "\n" + prefix)
    return outstr


@openflow_c_message("OFPT_FEATURES_REQUEST", 5,
    request_for="ofp_features_reply")
class ofp_features_request (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    #print ("pack ofp_features_request")
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    assert length == len(self)
    #print ("unpack ofp_features_request")
    return offset,length

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr



@openflow_c_message("OFPT_GET_CONFIG_REQUEST", 7,
    request_for="ofp_get_config_reply")
class ofp_get_config_request (ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    return packed

  #def unpack (self, raw, offset=0):
  #  offset,length = self._unpack_header(raw, offset)
  #  assert length == len(self)
  #  return offset,length

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr


@openflow_s_message("OFPT_GET_CONFIG_REPLY", 8,
    reply_to="ofp_get_config_request")
class ofp_get_config_reply (ofp_header): # uses ofp_switch_config
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.flags = 0
    self.miss_send_len = OFP_DEFAULT_MISS_SEND_LEN

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!HH", self.flags, self.miss_send_len)
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.flags, self.miss_send_len) = \
        _unpack("!HH", raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 12

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.flags != other.flags: return False
    if self.miss_send_len != other.miss_send_len: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'flags: ' + str(self.flags) + '\n'
    outstr += prefix + 'miss_send_len: ' + str(self.miss_send_len) + '\n'
    return outstr

  def SHOW(self):
    outstr = self.show()
    print (outstr)



"""
========================================================================
New Switch Message
========================================================================
"""

#6. Controller role change request messages    
@openflow_s_message("OFPT_ROLE_REQUEST", 25,  #add by Tan
    request_for="ofp_role_reply")
class ofp_role_request(ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr

@openflow_s_message("OFPT_ROLE_REPLY", 26,  #add by Tan
    reply_to="ofp_role_request")
class ofp_role_reply(ofp_header):
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 8

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    return outstr

@openflow_s_message("OFPT_METER_MOD", 30)   #add by Tan
class ofp_meter_mod(ofp_header):
  _MIN_LENGTH = 16
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.command = 0
    self.reverse = 0
    self.rate = 0
    self.meterID = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += ofp_header.pack(self)
    packed += struct.pack("!BBHL", self.command, self.reverse, self.rate, self.meterID)
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset,(self.command, self.reverse, self.rate, self.meterID) = _unpack("!BBHL", raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 16

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if not ofp_header.__eq__(self, other): return False
    if self.rate != other.rate: return False
    if self.meterID != other.meterID: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'rate: ' + str(self.rate) + '\n'
    outstr += prefix + 'meterID: ' + str(self.meterID) + '\n'
    return outstr



class ofp_counter(ofp_base):   #add by Tan
  _MIN_LENGTH = 16
  def __init__ (self, **kw):
    self.command = 0
    self.reverse = 0
    self.counterID = 0
    self.value = 0

    initHelper(self, kw)

  def pack (self):
    assert self._assert()

    packed = b""
    packed += struct.pack("!B", self.command)
    packed += _PAD * 3 
    packed += struct.pack("!LQ", self.counterID, self.value)
    return packed

  def unpack (self, raw, offset=0):
    offset,(self.command) = self._unpack_header(raw, offset)
    offset = _skip(raw, offset, 3)
    offset,(self.counterID, self.value) = _unpack("!LQ", raw, offset)
    return offset

  @staticmethod
  def __len__ ():
    return 16

  def __eq__ (self, other):
    if type(self) != type(other): return False
    if self.command != other.command: return False
    if self.reverse != other.reverse: return False
    if self.value != other.value: return False
    if self.meterID != other.meterID: return False
    return True

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'command: ' + str(self.command) + '\n'
    outstr += prefix + 'reverse: ' + str(self.reverse) + '\n'
    outstr += prefix + 'counterID: ' + str(self.counterID) + '\n'
    outstr += prefix + 'value: ' + str(self.value) + '\n'
    return outstr

@openflow_s_message("OFPT_COUNTER_MOD", 31)   #add by Tan
class ofp_counter_mod(ofp_header):
  _MIN_LENGTH = 24
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.counter = ofp_counter()

    initHelper(self, kw)


  def pack (self):
    assert self._assert()
    packed = b""
    packed += ofp_header.pack(self)
    packed += self.counter.pack()
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset = self.counter.unpack(raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 24

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'counter: \n'
    outstr += self.counter.show(prefix + '  ')
    return outstr   



@openflow_s_message("OFPT_COUNTER_REQUEST", 32,   #add by Tan
    request_for="ofp_counter_reply")
class ofp_counter_request(ofp_header):
  _MIN_LENGTH = 24
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.counter = ofp_counter()

    initHelper(self, kw)


  def pack (self):
    assert self._assert()
    packed = b""
    packed += ofp_header.pack(self)
    packed += self.counter.pack()
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset = self.counter.unpack(raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 24

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'counter: \n'
    outstr += self.counter.show(prefix + '  ')
    return outstr 

@openflow_s_message("OFPT_COUNTER_REPLY", 33,   #add by Tan
    reply_to="ofp_counter_request")
class ofp_counter_reply(ofp_header):
  _MIN_LENGTH = 24
  def __init__ (self, **kw):
    ofp_header.__init__(self)
    self.counter = ofp_counter()

    initHelper(self, kw)


  def pack (self):
    assert self._assert()
    packed = b""
    packed += ofp_header.pack(self)
    packed += self.counter.pack()
    return packed

  def unpack (self, raw, offset=0):
    offset,length = self._unpack_header(raw, offset)
    offset = self.counter.unpack(raw, offset)
    assert length == len(self)
    return offset,length

  @staticmethod
  def __len__ ():
    return 24

  def show (self, prefix=''):
    outstr = ''
    outstr += prefix + 'header: \n'
    outstr += ofp_header.show(self, prefix + '  ')
    outstr += prefix + 'counter: \n'
    outstr += self.counter.show(prefix + '  ')
    return outstr   




def _unpack_queue_props (b, length, offset=0):
  """
  Parses queue props from a buffer
  b is a buffer (bytes)
  offset, if specified, is where in b to start decoding
  returns (next_offset, [Pops])
  """
  if (len(b) - offset) < length: raise UnderrunError
  props = []
  end = length + offset
  while offset < end:
    (t,l) = struct.unpack_from("!HH", b, offset)
    if (len(b) - offset) < l: raise UnderrunError
    a = _queue_prop_type_to_class.get(t)
    if a is None:
      # Use generic prop header for unknown type
      a = ofp_queue_prop_generic()
    else:
      a = a()
    a.unpack(b[offset:offset+l])
    assert len(a) == l
    props.append(a)
    offset += l
  return (offset, props)

def _unpack_actions (b, length, offset=0):
  """
  Parses actions from a buffer
  b is a buffer (bytes)
  offset, if specified, is where in b to start decoding
  returns (next_offset, [Actions])
  """
  if (len(b) - offset) < length: raise UnderrunError
  actions = []
  end = length + offset
  while offset < end:
    (t,l) = struct.unpack_from("!HH", b, offset)
    if (len(b) - offset) < l: raise UnderrunError
    a = _action_type_to_class.get(t)
    if a is None:
      # Use generic action header for unknown type
      a = ofp_action_generic()
    else:
      a = a()
    a.unpack(b[offset:offset+l])
    assert len(a) == l
    actions.append(a)
    offset += l
  return (offset, actions)

def _init ():
  def formatMap (name, m):
    o = name + " = {\n"
    vk = sorted([(v,k) for k,v in m.iteritems()])
    maxlen = 2 + len(reduce(lambda a,b: a if len(a)>len(b) else b,
                            (v for k,v in vk)))
    fstr = "  %-" + str(maxlen) + "s : %s,\n"
    for v,k in vk:
      o += fstr % ("'" + k + "'",v)
    o += "}"
    return o
  """
  maps = []
  for k,v in globals().iteritems():
    if k.startswith("ofp_") and k.endswith("_map") and type(v) == dict:
      maps.append((k,v))
  for name,m in maps:
    rev = {}
    name = name[:-4]
    names = globals()[name]
    for n in names:
      rev[n] = globals()[n]

    globals()[name + '_rev_map'] = rev
    print(formatMap(name + "_rev_map", rev))
  return
  """
  maps = []
  for k,v in globals().iteritems():
    if (k.startswith("ofp_") and k.endswith("_rev_map")
        and type(v) == dict):
      maps.append((k[:-8],v))
  for name,m in maps:
    # Try to generate forward maps
    forward = dict(((v,k) for k,v in m.iteritems()))
    if len(forward) == len(m):
      if name + "_map" not in globals():
        globals()[name + "_map"] = forward
    else:
      print(name + "_rev_map is not a map")

    # Try to generate lists
    v = m.values()
    v.sort()
    if v[-1] != len(v)-1:
      # Allow ones where the last value is a special value (e.g., VENDOR)
      del v[-1]
    if len(v) > 0 and v[0] == 0 and v[-1] == len(v)-1:
      globals()[name] = v

    # Generate gobals
    for k,v in m.iteritems():
      globals()[k] = v


_init()
#abbc="  Test Const:"+str(OF_LINEAR_TABLE)
#print (abbc)


# Values from macro definitions
OFP_FLOW_PERMANENT = 0
OFP_DL_TYPE_ETH2_CUTOFF = 0x0600
DESC_STR_LEN = 256
OFPFW_ICMP_CODE = OFPFW_TP_DST
OFPQ_MIN_RATE_UNCFG = 0xffff
OFP_VERSION = 0x04
OFP_MAX_TABLE_NAME_LEN = 32
OFP_DL_TYPE_NOT_ETH_TYPE = 0x05ff
OFP_DEFAULT_MISS_SEND_LEN = 128
OFP_MAX_PORT_NAME_LEN = 64    ##POF  change from 16 to 64
OFP_SSL_PORT = 6633
OFPFW_ICMP_TYPE = OFPFW_TP_SRC
OFP_TCP_PORT = 6633
SERIAL_NUM_LEN = 32
OFP_DEFAULT_PRIORITY = 0x8000
OFP_VLAN_NONE = 0xffff
OFPQ_ALL = 0xffffffff




ofp_match_data = {        #should be a string?
  'in_port' : (0, OFPFW_IN_PORT),
  'dl_src' : (EMPTY_ETH, OFPFW_DL_SRC),
  'dl_dst' : (EMPTY_ETH, OFPFW_DL_DST),
  'dl_vlan' : (0, OFPFW_DL_VLAN),
  'dl_vlan_pcp' : (0, OFPFW_DL_VLAN_PCP),
  'dl_type' : (0, OFPFW_DL_TYPE),
  'nw_tos' : (0, OFPFW_NW_TOS),
  'nw_proto' : (0, OFPFW_NW_PROTO),
  'nw_src' : (0, OFPFW_NW_SRC_ALL),
  'nw_dst' : (0, OFPFW_NW_DST_ALL),
  'tp_src' : (0, OFPFW_TP_SRC),
  'tp_dst' : (0, OFPFW_TP_DST),
}